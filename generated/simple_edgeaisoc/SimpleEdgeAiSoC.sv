// Generated by CIRCT firtool-1.37.0
// VCS coverage exclude_file
module ram_combMem(
  input  [3:0] R0_addr,
  input        R0_en,
               R0_clk,
  input  [3:0] W0_addr,
  input        W0_en,
               W0_clk,
  input  [7:0] W0_data,
  output [7:0] R0_data
);

  reg [7:0] Memory[0:15];
  always @(posedge W0_clk) begin
    if (W0_en)
      Memory[W0_addr] <= W0_data;
  end // always @(posedge)
  assign R0_data = R0_en ? Memory[R0_addr] : 8'bx;
endmodule

// VCS coverage exclude_file
module matrixA_combMem(
  input  [5:0]  R0_addr,
  input         R0_en,
                R0_clk,
  input  [5:0]  W0_addr,
  input         W0_en,
                W0_clk,
  input  [31:0] W0_data,
  output [31:0] R0_data
);

  reg [31:0] Memory[0:63];
  always @(posedge W0_clk) begin
    if (W0_en)
      Memory[W0_addr] <= W0_data;
  end // always @(posedge)
  assign R0_data = R0_en ? Memory[R0_addr] : 32'bx;
endmodule

// VCS coverage exclude_file
module result_combMem(
  input  [7:0]  R0_addr,
  input         R0_en,
                R0_clk,
  input  [7:0]  W0_addr,
  input         W0_en,
                W0_clk,
  input  [31:0] W0_data,
  output [31:0] R0_data
);

  reg [31:0] Memory[0:255];
  always @(posedge W0_clk) begin
    if (W0_en)
      Memory[W0_addr] <= W0_data;
  end // always @(posedge)
  assign R0_data = R0_en ? Memory[R0_addr] : 32'bx;
endmodule

// VCS coverage exclude_file
module weight_combMem(
  input  [7:0] R0_addr,
  input        R0_en,
               R0_clk,
  input  [7:0] R1_addr,
  input        R1_en,
               R1_clk,
  input  [7:0] W0_addr,
  input        W0_en,
               W0_clk,
  input  [1:0] W0_data,
  output [1:0] R0_data,
               R1_data
);

  reg [1:0] Memory[0:255];
  always @(posedge W0_clk) begin
    if (W0_en)
      Memory[W0_addr] <= W0_data;
  end // always @(posedge)
  assign R0_data = R0_en ? Memory[R0_addr] : 2'bx;
  assign R1_data = R1_en ? Memory[R1_addr] : 2'bx;
endmodule

// VCS coverage exclude_file
module activation_combMem(
  input  [7:0]  R0_addr,
  input         R0_en,
                R0_clk,
  input  [7:0]  R1_addr,
  input         R1_en,
                R1_clk,
  input  [7:0]  W0_addr,
  input         W0_en,
                W0_clk,
  input  [31:0] W0_data,
  output [31:0] R0_data,
                R1_data
);

  reg [31:0] Memory[0:255];
  always @(posedge W0_clk) begin
    if (W0_en)
      Memory[W0_addr] <= W0_data;
  end // always @(posedge)
  assign R0_data = R0_en ? Memory[R0_addr] : 32'bx;
  assign R1_data = R1_en ? Memory[R1_addr] : 32'bx;
endmodule

module Control(
  input        io_jump_flag,
               io_jump_instruction_id,
  input  [4:0] io_rs1_id,
               io_rs2_id,
  input        io_memory_read_enable_ex,
  input  [4:0] io_rd_ex,
  input        io_memory_read_enable_mem,
  input  [4:0] io_rd_mem,
  output       io_if_flush,
               io_id_flush,
               io_pc_stall,
               io_if_stall
);

  wire _T_14 =
    (io_jump_instruction_id | io_memory_read_enable_ex) & (|io_rd_ex)
    & (io_rd_ex == io_rs1_id | io_rd_ex == io_rs2_id) | io_jump_instruction_id
    & io_memory_read_enable_mem & (|io_rd_mem)
    & (io_rd_mem == io_rs1_id | io_rd_mem == io_rs2_id);
  assign io_if_flush = ~_T_14 & io_jump_flag;
  assign io_id_flush = _T_14;
  assign io_pc_stall = _T_14;
  assign io_if_stall = _T_14;
endmodule

module RegisterFile(
  input         clock,
                reset,
                io_write_enable,
  input  [4:0]  io_write_address,
  input  [31:0] io_write_data,
  input  [4:0]  io_read_address1,
                io_read_address2,
  output [31:0] io_read_data1,
                io_read_data2
);

  reg  [31:0]       registers_0;
  reg  [31:0]       registers_1;
  reg  [31:0]       registers_2;
  reg  [31:0]       registers_3;
  reg  [31:0]       registers_4;
  reg  [31:0]       registers_5;
  reg  [31:0]       registers_6;
  reg  [31:0]       registers_7;
  reg  [31:0]       registers_8;
  reg  [31:0]       registers_9;
  reg  [31:0]       registers_10;
  reg  [31:0]       registers_11;
  reg  [31:0]       registers_12;
  reg  [31:0]       registers_13;
  reg  [31:0]       registers_14;
  reg  [31:0]       registers_15;
  reg  [31:0]       registers_16;
  reg  [31:0]       registers_17;
  reg  [31:0]       registers_18;
  reg  [31:0]       registers_19;
  reg  [31:0]       registers_20;
  reg  [31:0]       registers_21;
  reg  [31:0]       registers_22;
  reg  [31:0]       registers_23;
  reg  [31:0]       registers_24;
  reg  [31:0]       registers_25;
  reg  [31:0]       registers_26;
  reg  [31:0]       registers_27;
  reg  [31:0]       registers_28;
  reg  [31:0]       registers_29;
  reg  [31:0]       registers_30;
  wire [31:0][31:0] _GEN =
    {{registers_0},
     {registers_30},
     {registers_29},
     {registers_28},
     {registers_27},
     {registers_26},
     {registers_25},
     {registers_24},
     {registers_23},
     {registers_22},
     {registers_21},
     {registers_20},
     {registers_19},
     {registers_18},
     {registers_17},
     {registers_16},
     {registers_15},
     {registers_14},
     {registers_13},
     {registers_12},
     {registers_11},
     {registers_10},
     {registers_9},
     {registers_8},
     {registers_7},
     {registers_6},
     {registers_5},
     {registers_4},
     {registers_3},
     {registers_2},
     {registers_1},
     {registers_0}};
  always @(posedge clock) begin
    automatic logic       _T_3 = io_write_enable & (|io_write_address);
    automatic logic [4:0] _T_5 = io_write_address - 5'h1;
    if (~reset & _T_3 & _T_5 == 5'h0)
      registers_0 <= io_write_data;
    if (~reset & _T_3 & _T_5 == 5'h1)
      registers_1 <= io_write_data;
    if (~reset & _T_3 & _T_5 == 5'h2)
      registers_2 <= io_write_data;
    if (~reset & _T_3 & _T_5 == 5'h3)
      registers_3 <= io_write_data;
    if (~reset & _T_3 & _T_5 == 5'h4)
      registers_4 <= io_write_data;
    if (~reset & _T_3 & _T_5 == 5'h5)
      registers_5 <= io_write_data;
    if (~reset & _T_3 & _T_5 == 5'h6)
      registers_6 <= io_write_data;
    if (~reset & _T_3 & _T_5 == 5'h7)
      registers_7 <= io_write_data;
    if (~reset & _T_3 & _T_5 == 5'h8)
      registers_8 <= io_write_data;
    if (~reset & _T_3 & _T_5 == 5'h9)
      registers_9 <= io_write_data;
    if (~reset & _T_3 & _T_5 == 5'hA)
      registers_10 <= io_write_data;
    if (~reset & _T_3 & _T_5 == 5'hB)
      registers_11 <= io_write_data;
    if (~reset & _T_3 & _T_5 == 5'hC)
      registers_12 <= io_write_data;
    if (~reset & _T_3 & _T_5 == 5'hD)
      registers_13 <= io_write_data;
    if (~reset & _T_3 & _T_5 == 5'hE)
      registers_14 <= io_write_data;
    if (~reset & _T_3 & _T_5 == 5'hF)
      registers_15 <= io_write_data;
    if (~reset & _T_3 & _T_5 == 5'h10)
      registers_16 <= io_write_data;
    if (~reset & _T_3 & _T_5 == 5'h11)
      registers_17 <= io_write_data;
    if (~reset & _T_3 & _T_5 == 5'h12)
      registers_18 <= io_write_data;
    if (~reset & _T_3 & _T_5 == 5'h13)
      registers_19 <= io_write_data;
    if (~reset & _T_3 & _T_5 == 5'h14)
      registers_20 <= io_write_data;
    if (~reset & _T_3 & _T_5 == 5'h15)
      registers_21 <= io_write_data;
    if (~reset & _T_3 & _T_5 == 5'h16)
      registers_22 <= io_write_data;
    if (~reset & _T_3 & _T_5 == 5'h17)
      registers_23 <= io_write_data;
    if (~reset & _T_3 & _T_5 == 5'h18)
      registers_24 <= io_write_data;
    if (~reset & _T_3 & _T_5 == 5'h19)
      registers_25 <= io_write_data;
    if (~reset & _T_3 & _T_5 == 5'h1A)
      registers_26 <= io_write_data;
    if (~reset & _T_3 & _T_5 == 5'h1B)
      registers_27 <= io_write_data;
    if (~reset & _T_3 & _T_5 == 5'h1C)
      registers_28 <= io_write_data;
    if (~reset & _T_3 & _T_5 == 5'h1D)
      registers_29 <= io_write_data;
    if (~reset & _T_3 & _T_5 == 5'h1E)
      registers_30 <= io_write_data;
  end // always @(posedge)
  assign io_read_data1 =
    io_read_address1 == 5'h0
      ? 32'h0
      : io_read_address1 == io_write_address & io_write_enable
          ? io_write_data
          : _GEN[io_read_address1 - 5'h1];
  assign io_read_data2 =
    io_read_address2 == 5'h0
      ? 32'h0
      : io_read_address2 == io_write_address & io_write_enable
          ? io_write_data
          : _GEN[io_read_address2 - 5'h1];
endmodule

module InstructionFetch(
  input         clock,
                reset,
                io_stall_flag_ctrl,
                io_jump_flag_id,
  input  [31:0] io_jump_address_id,
                io_rom_instruction,
  input         io_instruction_valid,
  output [31:0] io_instruction_address,
                io_id_instruction
);

  reg [31:0] pc;
  always @(posedge clock) begin
    if (reset)
      pc <= 32'h1000;
    else if (io_jump_flag_id & ~io_stall_flag_ctrl)
      pc <= io_jump_address_id;
    else if (~(io_stall_flag_ctrl | ~io_instruction_valid))
      pc <= pc + 32'h4;
  end // always @(posedge)
  assign io_instruction_address = pc;
  assign io_id_instruction = io_instruction_valid ? io_rom_instruction : 32'h13;
endmodule

module PipelineRegister(
  input         clock,
                reset,
                io_stall,
                io_flush,
  input  [31:0] io_in,
  output [31:0] io_out
);

  reg [31:0] reg_0;
  always @(posedge clock) begin
    if (reset)
      reg_0 <= 32'h13;
    else if (io_flush)
      reg_0 <= 32'h13;
    else if (io_stall) begin
    end
    else
      reg_0 <= io_in;
  end // always @(posedge)
  assign io_out = reg_0;
endmodule

module PipelineRegister_1(
  input         clock,
                reset,
                io_stall,
                io_flush,
  input  [31:0] io_in,
  output [31:0] io_out
);

  reg [31:0] reg_0;
  always @(posedge clock) begin
    if (reset)
      reg_0 <= 32'h1000;
    else if (io_flush)
      reg_0 <= 32'h1000;
    else if (io_stall) begin
    end
    else
      reg_0 <= io_in;
  end // always @(posedge)
  assign io_out = reg_0;
endmodule

module PipelineRegister_2(
  input         clock,
                reset,
                io_stall,
                io_flush,
  input  [31:0] io_in,
  output [31:0] io_out
);

  reg [31:0] reg_0;
  always @(posedge clock) begin
    if (reset)
      reg_0 <= 32'h0;
    else if (io_flush)
      reg_0 <= 32'h0;
    else if (io_stall) begin
    end
    else
      reg_0 <= io_in;
  end // always @(posedge)
  assign io_out = reg_0;
endmodule

module IF2ID(
  input         clock,
                reset,
                io_stall,
                io_flush,
  input  [31:0] io_instruction,
                io_instruction_address,
                io_interrupt_flag,
  output [31:0] io_output_instruction,
                io_output_instruction_address,
                io_output_interrupt_flag
);

  PipelineRegister instruction (
    .clock    (clock),
    .reset    (reset),
    .io_stall (io_stall),
    .io_flush (io_flush),
    .io_in    (io_instruction),
    .io_out   (io_output_instruction)
  );
  PipelineRegister_1 instruction_address (
    .clock    (clock),
    .reset    (reset),
    .io_stall (io_stall),
    .io_flush (io_flush),
    .io_in    (io_instruction_address),
    .io_out   (io_output_instruction_address)
  );
  PipelineRegister_2 interrupt_flag (
    .clock    (clock),
    .reset    (reset),
    .io_stall (io_stall),
    .io_flush (io_flush),
    .io_in    (io_interrupt_flag),
    .io_out   (io_output_interrupt_flag)
  );
endmodule

module InstructionDecode(
  input  [31:0] io_instruction,
                io_instruction_address,
                io_reg1_data,
                io_reg2_data,
                io_forward_from_mem,
                io_forward_from_wb,
  input  [1:0]  io_reg1_forward,
                io_reg2_forward,
  input         io_interrupt_assert,
  input  [31:0] io_interrupt_handler_address,
  output [4:0]  io_regs_reg1_read_address,
                io_regs_reg2_read_address,
  output [31:0] io_ex_immediate,
  output        io_ex_aluop1_source,
                io_ex_aluop2_source,
                io_ex_memory_read_enable,
                io_ex_memory_write_enable,
  output [1:0]  io_ex_reg_write_source,
  output        io_ex_reg_write_enable,
  output [4:0]  io_ex_reg_write_address,
  output [11:0] io_ex_csr_address,
  output        io_ex_csr_write_enable,
                io_ctrl_jump_instruction,
                io_clint_jump_flag,
  output [31:0] io_clint_jump_address,
  output        io_if_jump_flag,
  output [31:0] io_if_jump_address
);

  wire             _io_ex_reg_write_enable_T_7 = io_instruction[6:0] == 7'h37;
  wire             _io_ex_reg_write_enable_T_1 = io_instruction[6:0] == 7'h13;
  wire             _io_ex_reg_write_enable_T_3 = io_instruction[6:0] == 7'h3;
  wire             _io_clint_jump_address_T_10 = io_instruction[6:0] == 7'h67;
  wire             _io_ex_memory_write_enable_T = io_instruction[6:0] == 7'h23;
  wire             _io_clint_jump_address_T_6 = io_instruction[6:0] == 7'h63;
  wire             _io_ex_reg_write_enable_T_5 = io_instruction[6:0] == 7'h17;
  wire             _io_clint_jump_address_T_8 = io_instruction[6:0] == 7'h6F;
  wire [31:0]      _io_ex_immediate_output =
    _io_clint_jump_address_T_8
      ? {{12{io_instruction[31]}},
         io_instruction[19:12],
         io_instruction[20],
         io_instruction[30:21],
         1'h0}
      : _io_ex_reg_write_enable_T_5
          ? {io_instruction[31:12], 12'h0}
          : _io_ex_reg_write_enable_T_7
              ? {io_instruction[31:12], 12'h0}
              : {{20{io_instruction[31]}},
                 _io_clint_jump_address_T_6
                   ? {io_instruction[7],
                      io_instruction[30:25],
                      io_instruction[11:8],
                      1'h0}
                   : _io_ex_memory_write_enable_T
                       ? {io_instruction[31:25], io_instruction[11:7]}
                       : _io_clint_jump_address_T_10 | _io_ex_reg_write_enable_T_3
                         | _io_ex_reg_write_enable_T_1
                           ? io_instruction[31:20]
                           : io_instruction[31:20]};
  wire             _io_ex_reg_write_enable_T = io_instruction[6:0] == 7'h33;
  wire             _io_ex_csr_write_enable_T = io_instruction[6:0] == 7'h73;
  wire [3:0][31:0] _GEN =
    {{32'h0}, {io_forward_from_wb}, {io_forward_from_mem}, {io_reg1_data}};
  wire [3:0][31:0] _GEN_0 =
    {{32'h0}, {io_forward_from_wb}, {io_forward_from_mem}, {io_reg2_data}};
  wire             _io_ctrl_jump_instruction_output =
    _io_clint_jump_address_T_8 | _io_clint_jump_address_T_10 | _io_clint_jump_address_T_6;
  wire             _io_if_jump_flag_T_15 =
    io_instruction[14:12] == 3'h0 & _GEN[io_reg1_forward] == _GEN_0[io_reg2_forward];
  wire [7:0]       _GEN_1 =
    {{_GEN[io_reg1_forward] >= _GEN_0[io_reg2_forward]},
     {_GEN[io_reg1_forward] < _GEN_0[io_reg2_forward]},
     {$signed(_GEN[io_reg1_forward]) >= $signed(_GEN_0[io_reg2_forward])},
     {$signed(_GEN[io_reg1_forward]) < $signed(_GEN_0[io_reg2_forward])},
     {_io_if_jump_flag_T_15},
     {_io_if_jump_flag_T_15},
     {_GEN[io_reg1_forward] != _GEN_0[io_reg2_forward]},
     {_io_if_jump_flag_T_15}};
  wire [31:0]      _io_if_jump_address_T_1 =
    io_instruction_address + _io_ex_immediate_output;
  wire [31:0]      _io_if_jump_address_T_5 =
    _GEN[io_reg1_forward] + _io_ex_immediate_output;
  wire             _GEN_2 = _io_clint_jump_address_T_8 | _io_clint_jump_address_T_6;
  assign io_regs_reg1_read_address =
    _io_ex_reg_write_enable_T_7 ? 5'h0 : io_instruction[19:15];
  assign io_regs_reg2_read_address = io_instruction[24:20];
  assign io_ex_immediate = _io_ex_immediate_output;
  assign io_ex_aluop1_source =
    _io_ex_reg_write_enable_T_5 | _io_clint_jump_address_T_6 | _io_clint_jump_address_T_8;
  assign io_ex_aluop2_source = ~_io_ex_reg_write_enable_T;
  assign io_ex_memory_read_enable = _io_ex_reg_write_enable_T_3;
  assign io_ex_memory_write_enable = _io_ex_memory_write_enable_T;
  assign io_ex_reg_write_source =
    _io_clint_jump_address_T_10 | _io_clint_jump_address_T_8
      ? 2'h3
      : _io_ex_csr_write_enable_T ? 2'h2 : {1'h0, _io_ex_reg_write_enable_T_3};
  assign io_ex_reg_write_enable =
    _io_ex_reg_write_enable_T | _io_ex_reg_write_enable_T_1 | _io_ex_reg_write_enable_T_3
    | _io_ex_reg_write_enable_T_5 | _io_ex_reg_write_enable_T_7
    | _io_clint_jump_address_T_8 | _io_clint_jump_address_T_10
    | _io_ex_csr_write_enable_T;
  assign io_ex_reg_write_address = io_instruction[11:7];
  assign io_ex_csr_address = io_instruction[31:20];
  assign io_ex_csr_write_enable =
    _io_ex_csr_write_enable_T
    & (io_instruction[14:12] == 3'h1 | io_instruction[14:12] == 3'h5
       | io_instruction[14:12] == 3'h2 | io_instruction[14:12] == 3'h6
       | io_instruction[14:12] == 3'h3 | (&(io_instruction[14:12])));
  assign io_ctrl_jump_instruction = _io_ctrl_jump_instruction_output;
  assign io_clint_jump_flag = _io_ctrl_jump_instruction_output;
  assign io_clint_jump_address =
    _io_clint_jump_address_T_10
      ? _io_if_jump_address_T_5
      : _GEN_2 ? _io_if_jump_address_T_1 : 32'h0;
  assign io_if_jump_flag =
    _io_clint_jump_address_T_8 | _io_clint_jump_address_T_10 | _io_clint_jump_address_T_6
    & _GEN_1[io_instruction[14:12]] | io_interrupt_assert;
  assign io_if_jump_address =
    io_interrupt_assert
      ? io_interrupt_handler_address
      : _io_clint_jump_address_T_10
          ? _io_if_jump_address_T_5
          : _GEN_2 ? _io_if_jump_address_T_1 : 32'h0;
endmodule

module PipelineRegister_5(
  input        clock,
               reset,
               io_flush,
  input  [4:0] io_in,
  output [4:0] io_out
);

  reg [4:0] reg_0;
  always @(posedge clock) begin
    if (reset)
      reg_0 <= 5'h0;
    else if (io_flush)
      reg_0 <= 5'h0;
    else
      reg_0 <= io_in;
  end // always @(posedge)
  assign io_out = reg_0;
endmodule

module PipelineRegister_7(
  input  clock,
         reset,
         io_flush,
         io_in,
  output io_out
);

  reg reg_0;
  always @(posedge clock) begin
    if (reset)
      reg_0 <= 1'h0;
    else
      reg_0 <= ~io_flush & io_in;
  end // always @(posedge)
  assign io_out = reg_0;
endmodule

module PipelineRegister_9(
  input        clock,
               reset,
               io_flush,
  input  [1:0] io_in,
  output [1:0] io_out
);

  reg [1:0] reg_0;
  always @(posedge clock) begin
    if (reset)
      reg_0 <= 2'h0;
    else if (io_flush)
      reg_0 <= 2'h0;
    else
      reg_0 <= io_in;
  end // always @(posedge)
  assign io_out = reg_0;
endmodule

module PipelineRegister_16(
  input         clock,
                reset,
                io_flush,
  input  [11:0] io_in,
  output [11:0] io_out
);

  reg [11:0] reg_0;
  always @(posedge clock) begin
    if (reset)
      reg_0 <= 12'h0;
    else if (io_flush)
      reg_0 <= 12'h0;
    else
      reg_0 <= io_in;
  end // always @(posedge)
  assign io_out = reg_0;
endmodule

module ID2EX(
  input         clock,
                reset,
                io_flush,
  input  [31:0] io_instruction,
                io_instruction_address,
  input  [4:0]  io_regs_reg1_read_address,
                io_regs_reg2_read_address,
  input         io_regs_write_enable,
  input  [4:0]  io_regs_write_address,
  input  [1:0]  io_regs_write_source,
  input  [31:0] io_reg1_data,
                io_reg2_data,
                io_immediate,
  input         io_aluop1_source,
                io_aluop2_source,
                io_csr_write_enable,
  input  [11:0] io_csr_address,
  input         io_memory_read_enable,
                io_memory_write_enable,
  input  [31:0] io_csr_read_data,
  output [31:0] io_output_instruction,
                io_output_instruction_address,
  output [4:0]  io_output_regs_reg1_read_address,
                io_output_regs_reg2_read_address,
  output        io_output_regs_write_enable,
  output [4:0]  io_output_regs_write_address,
  output [1:0]  io_output_regs_write_source,
  output [31:0] io_output_reg1_data,
                io_output_reg2_data,
                io_output_immediate,
  output        io_output_aluop1_source,
                io_output_aluop2_source,
                io_output_csr_write_enable,
  output [11:0] io_output_csr_address,
  output        io_output_memory_read_enable,
                io_output_memory_write_enable,
  output [31:0] io_output_csr_read_data
);

  PipelineRegister instruction (
    .clock    (clock),
    .reset    (reset),
    .io_stall (1'h0),
    .io_flush (io_flush),
    .io_in    (io_instruction),
    .io_out   (io_output_instruction)
  );
  PipelineRegister_1 instruction_address (
    .clock    (clock),
    .reset    (reset),
    .io_stall (1'h0),
    .io_flush (io_flush),
    .io_in    (io_instruction_address),
    .io_out   (io_output_instruction_address)
  );
  PipelineRegister_5 regs_reg1_read_address (
    .clock    (clock),
    .reset    (reset),
    .io_flush (io_flush),
    .io_in    (io_regs_reg1_read_address),
    .io_out   (io_output_regs_reg1_read_address)
  );
  PipelineRegister_5 regs_reg2_read_address (
    .clock    (clock),
    .reset    (reset),
    .io_flush (io_flush),
    .io_in    (io_regs_reg2_read_address),
    .io_out   (io_output_regs_reg2_read_address)
  );
  PipelineRegister_7 regs_write_enable (
    .clock    (clock),
    .reset    (reset),
    .io_flush (io_flush),
    .io_in    (io_regs_write_enable),
    .io_out   (io_output_regs_write_enable)
  );
  PipelineRegister_5 regs_write_address (
    .clock    (clock),
    .reset    (reset),
    .io_flush (io_flush),
    .io_in    (io_regs_write_address),
    .io_out   (io_output_regs_write_address)
  );
  PipelineRegister_9 regs_write_source (
    .clock    (clock),
    .reset    (reset),
    .io_flush (io_flush),
    .io_in    (io_regs_write_source),
    .io_out   (io_output_regs_write_source)
  );
  PipelineRegister_2 reg1_data (
    .clock    (clock),
    .reset    (reset),
    .io_stall (1'h0),
    .io_flush (io_flush),
    .io_in    (io_reg1_data),
    .io_out   (io_output_reg1_data)
  );
  PipelineRegister_2 reg2_data (
    .clock    (clock),
    .reset    (reset),
    .io_stall (1'h0),
    .io_flush (io_flush),
    .io_in    (io_reg2_data),
    .io_out   (io_output_reg2_data)
  );
  PipelineRegister_2 immediate (
    .clock    (clock),
    .reset    (reset),
    .io_stall (1'h0),
    .io_flush (io_flush),
    .io_in    (io_immediate),
    .io_out   (io_output_immediate)
  );
  PipelineRegister_7 aluop1_source (
    .clock    (clock),
    .reset    (reset),
    .io_flush (io_flush),
    .io_in    (io_aluop1_source),
    .io_out   (io_output_aluop1_source)
  );
  PipelineRegister_7 aluop2_source (
    .clock    (clock),
    .reset    (reset),
    .io_flush (io_flush),
    .io_in    (io_aluop2_source),
    .io_out   (io_output_aluop2_source)
  );
  PipelineRegister_7 csr_write_enable (
    .clock    (clock),
    .reset    (reset),
    .io_flush (io_flush),
    .io_in    (io_csr_write_enable),
    .io_out   (io_output_csr_write_enable)
  );
  PipelineRegister_16 csr_address (
    .clock    (clock),
    .reset    (reset),
    .io_flush (io_flush),
    .io_in    (io_csr_address),
    .io_out   (io_output_csr_address)
  );
  PipelineRegister_7 memory_read_enable (
    .clock    (clock),
    .reset    (reset),
    .io_flush (io_flush),
    .io_in    (io_memory_read_enable),
    .io_out   (io_output_memory_read_enable)
  );
  PipelineRegister_7 memory_write_enable (
    .clock    (clock),
    .reset    (reset),
    .io_flush (io_flush),
    .io_in    (io_memory_write_enable),
    .io_out   (io_output_memory_write_enable)
  );
  PipelineRegister_2 csr_read_data (
    .clock    (clock),
    .reset    (reset),
    .io_stall (1'h0),
    .io_flush (io_flush),
    .io_in    (io_csr_read_data),
    .io_out   (io_output_csr_read_data)
  );
endmodule

module ALU(
  input  [3:0]  io_func,
  input  [31:0] io_op1,
                io_op2,
  output [31:0] io_result
);

  wire [62:0]       _io_result_T_5 = {31'h0, io_op1} << io_op2[4:0];
  wire [15:0][31:0] _GEN =
    {{32'h0},
     {32'h0},
     {32'h0},
     {32'h0},
     {32'h0},
     {{31'h0, io_op1 < io_op2}},
     {$signed($signed(io_op1) >>> io_op2[4:0])},
     {io_op1 >> io_op2[4:0]},
     {io_op1 & io_op2},
     {io_op1 | io_op2},
     {io_op1 ^ io_op2},
     {{31'h0, $signed(io_op1) < $signed(io_op2)}},
     {_io_result_T_5[31:0]},
     {io_op1 - io_op2},
     {io_op1 + io_op2},
     {32'h0}};
  assign io_result = _GEN[io_func];
endmodule

module ALUControl(
  input  [6:0] io_opcode,
  input  [2:0] io_funct3,
  input  [6:0] io_funct7,
  output [3:0] io_alu_funct
);

  wire [3:0]      _GEN =
    {1'h0, io_funct3 == 3'h2 ? 3'h4 : {1'h0, io_funct3 == 3'h1, 1'h1}};
  wire [7:0][3:0] _GEN_0 =
    {{4'h7}, {4'h6}, {{3'h4, io_funct7[5]}}, {4'h5}, {4'hA}, {_GEN}, {_GEN}, {_GEN}};
  wire [3:0]      _GEN_1 =
    {1'h0,
     io_funct3 == 3'h2
       ? 3'h4
       : {1'h0, io_funct3 == 3'h1 ? 2'h3 : io_funct7[5] ? 2'h2 : 2'h1}};
  wire [7:0][3:0] _GEN_2 =
    {{4'h7},
     {4'h6},
     {{3'h4, io_funct7[5]}},
     {4'h5},
     {4'hA},
     {_GEN_1},
     {_GEN_1},
     {_GEN_1}};
  assign io_alu_funct =
    io_opcode == 7'h13
      ? _GEN_0[io_funct3]
      : io_opcode == 7'h33
          ? _GEN_2[io_funct3]
          : {3'h0,
             io_opcode == 7'h63 | io_opcode == 7'h3 | io_opcode == 7'h23
               | io_opcode == 7'h6F | io_opcode == 7'h67 | io_opcode == 7'h37
               | io_opcode == 7'h17};
endmodule

module Execute(
  input  [31:0] io_instruction,
                io_instruction_address,
                io_reg1_data,
                io_reg2_data,
                io_immediate,
  input         io_aluop1_source,
                io_aluop2_source,
  input  [31:0] io_csr_read_data,
                io_forward_from_mem,
                io_forward_from_wb,
  input  [1:0]  io_reg1_forward,
                io_reg2_forward,
  output [31:0] io_mem_alu_result,
                io_mem_reg2_data,
                io_csr_write_data
);

  wire [3:0]       _alu_ctrl_io_alu_funct;
  wire [31:0]      reg1_data =
    io_reg1_forward == 2'h2
      ? io_forward_from_wb
      : io_reg1_forward == 2'h1 ? io_forward_from_mem : io_reg1_data;
  wire [31:0]      reg2_data =
    io_reg2_forward == 2'h2
      ? io_forward_from_wb
      : io_reg2_forward == 2'h1 ? io_forward_from_mem : io_reg2_data;
  wire [31:0]      _io_csr_write_data_T_7 = {27'h0, io_instruction[19:15]};
  wire [7:0][31:0] _GEN =
    {{io_csr_read_data & {27'h7FFFFFF, ~(io_instruction[19:15])}},
     {io_csr_read_data | _io_csr_write_data_T_7},
     {_io_csr_write_data_T_7},
     {32'h0},
     {io_csr_read_data & ~reg1_data},
     {io_csr_read_data | reg1_data},
     {reg1_data},
     {32'h0}};
  ALU alu (
    .io_func   (_alu_ctrl_io_alu_funct),
    .io_op1    (io_aluop1_source ? io_instruction_address : reg1_data),
    .io_op2    (io_aluop2_source ? io_immediate : reg2_data),
    .io_result (io_mem_alu_result)
  );
  ALUControl alu_ctrl (
    .io_opcode    (io_instruction[6:0]),
    .io_funct3    (io_instruction[14:12]),
    .io_funct7    (io_instruction[31:25]),
    .io_alu_funct (_alu_ctrl_io_alu_funct)
  );
  assign io_mem_reg2_data = reg2_data;
  assign io_csr_write_data = _GEN[io_instruction[14:12]];
endmodule

module PipelineRegister_24(
  input        clock,
               reset,
  input  [2:0] io_in,
  output [2:0] io_out
);

  reg [2:0] reg_0;
  always @(posedge clock) begin
    if (reset)
      reg_0 <= 3'h0;
    else
      reg_0 <= io_in;
  end // always @(posedge)
  assign io_out = reg_0;
endmodule

module EX2MEM(
  input         clock,
                reset,
                io_regs_write_enable,
  input  [1:0]  io_regs_write_source,
  input  [31:0] io_regs_write_address,
                io_instruction_address,
  input  [2:0]  io_funct3,
  input  [31:0] io_reg2_data,
  input         io_memory_read_enable,
                io_memory_write_enable,
  input  [31:0] io_alu_result,
                io_csr_read_data,
  output        io_output_regs_write_enable,
  output [1:0]  io_output_regs_write_source,
  output [31:0] io_output_regs_write_address,
                io_output_instruction_address,
                io_output_funct3,
                io_output_reg2_data,
  output        io_output_memory_read_enable,
                io_output_memory_write_enable,
  output [31:0] io_output_alu_result,
                io_output_csr_read_data
);

  wire [2:0] _funct3_io_out;
  wire [4:0] _regs_write_address_io_out;
  PipelineRegister_7 regs_write_enable (
    .clock    (clock),
    .reset    (reset),
    .io_flush (1'h0),
    .io_in    (io_regs_write_enable),
    .io_out   (io_output_regs_write_enable)
  );
  PipelineRegister_9 regs_write_source (
    .clock    (clock),
    .reset    (reset),
    .io_flush (1'h0),
    .io_in    (io_regs_write_source),
    .io_out   (io_output_regs_write_source)
  );
  PipelineRegister_5 regs_write_address (
    .clock    (clock),
    .reset    (reset),
    .io_flush (1'h0),
    .io_in    (io_regs_write_address[4:0]),
    .io_out   (_regs_write_address_io_out)
  );
  PipelineRegister_2 instruction_address (
    .clock    (clock),
    .reset    (reset),
    .io_stall (1'h0),
    .io_flush (1'h0),
    .io_in    (io_instruction_address),
    .io_out   (io_output_instruction_address)
  );
  PipelineRegister_24 funct3 (
    .clock  (clock),
    .reset  (reset),
    .io_in  (io_funct3),
    .io_out (_funct3_io_out)
  );
  PipelineRegister_2 reg2_data (
    .clock    (clock),
    .reset    (reset),
    .io_stall (1'h0),
    .io_flush (1'h0),
    .io_in    (io_reg2_data),
    .io_out   (io_output_reg2_data)
  );
  PipelineRegister_2 alu_result (
    .clock    (clock),
    .reset    (reset),
    .io_stall (1'h0),
    .io_flush (1'h0),
    .io_in    (io_alu_result),
    .io_out   (io_output_alu_result)
  );
  PipelineRegister_7 memory_read_enable (
    .clock    (clock),
    .reset    (reset),
    .io_flush (1'h0),
    .io_in    (io_memory_read_enable),
    .io_out   (io_output_memory_read_enable)
  );
  PipelineRegister_7 memory_write_enable (
    .clock    (clock),
    .reset    (reset),
    .io_flush (1'h0),
    .io_in    (io_memory_write_enable),
    .io_out   (io_output_memory_write_enable)
  );
  PipelineRegister_2 csr_read_data (
    .clock    (clock),
    .reset    (reset),
    .io_stall (1'h0),
    .io_flush (1'h0),
    .io_in    (io_csr_read_data),
    .io_out   (io_output_csr_read_data)
  );
  assign io_output_regs_write_address = {27'h0, _regs_write_address_io_out};
  assign io_output_funct3 = {29'h0, _funct3_io_out};
endmodule

module MemoryAccess(
  input  [31:0] io_alu_result,
                io_reg2_data,
  input         io_memory_read_enable,
                io_memory_write_enable,
  input  [2:0]  io_funct3,
  input  [1:0]  io_regs_write_source,
  input  [31:0] io_csr_read_data,
                io_bundle_read_data,
  output [31:0] io_wb_memory_read_data,
                io_forward_data,
                io_bundle_address,
                io_bundle_write_data,
  output        io_bundle_write_enable
);

  wire [15:0]     half =
    io_alu_result[1] ? io_bundle_read_data[31:16] : io_bundle_read_data[15:0];
  wire [3:0][7:0] _GEN =
    {{io_bundle_read_data[31:24]},
     {io_bundle_read_data[23:16]},
     {io_bundle_read_data[15:8]},
     {io_bundle_read_data[7:0]}};
  wire [7:0]      _GEN_0 = _GEN[io_alu_result[1:0]];
  wire [38:0]     _writeData_T_2 =
    {31'h0, io_reg2_data[7:0]} << {34'h0, io_alu_result[1:0], 3'h0};
  assign io_wb_memory_read_data =
    io_memory_read_enable
      ? (io_funct3 == 3'h2
           ? io_bundle_read_data
           : io_funct3 == 3'h5
               ? {16'h0, half}
               : io_funct3 == 3'h1
                   ? {{16{half[15]}}, half}
                   : io_funct3 == 3'h4
                       ? {24'h0, _GEN_0}
                       : (|io_funct3) ? 32'h0 : {{24{_GEN_0[7]}}, _GEN_0})
      : 32'h0;
  assign io_forward_data =
    io_regs_write_source == 2'h2 ? io_csr_read_data : io_alu_result;
  assign io_bundle_address = io_alu_result;
  assign io_bundle_write_data =
    io_memory_read_enable | ~io_memory_write_enable
      ? 32'h0
      : (|io_funct3)
          ? (io_funct3 == 3'h1
               ? (io_alu_result[1]
                    ? {io_reg2_data[15:0], 16'h0}
                    : {16'h0, io_reg2_data[15:0]})
               : io_funct3 == 3'h2 ? io_reg2_data : 32'h0)
          : _writeData_T_2[31:0];
  assign io_bundle_write_enable = ~io_memory_read_enable & io_memory_write_enable;
endmodule

module MEM2WB(
  input         clock,
                reset,
  input  [31:0] io_instruction_address,
                io_alu_result,
  input         io_regs_write_enable,
  input  [1:0]  io_regs_write_source,
  input  [31:0] io_regs_write_address,
                io_memory_read_data,
                io_csr_read_data,
  output [31:0] io_output_instruction_address,
                io_output_alu_result,
  output        io_output_regs_write_enable,
  output [1:0]  io_output_regs_write_source,
  output [31:0] io_output_regs_write_address,
                io_output_memory_read_data,
                io_output_csr_read_data
);

  wire [4:0] _regs_write_address_io_out;
  PipelineRegister_2 alu_result (
    .clock    (clock),
    .reset    (reset),
    .io_stall (1'h0),
    .io_flush (1'h0),
    .io_in    (io_alu_result),
    .io_out   (io_output_alu_result)
  );
  PipelineRegister_2 memory_read_data (
    .clock    (clock),
    .reset    (reset),
    .io_stall (1'h0),
    .io_flush (1'h0),
    .io_in    (io_memory_read_data),
    .io_out   (io_output_memory_read_data)
  );
  PipelineRegister_7 regs_write_enable (
    .clock    (clock),
    .reset    (reset),
    .io_flush (1'h0),
    .io_in    (io_regs_write_enable),
    .io_out   (io_output_regs_write_enable)
  );
  PipelineRegister_9 regs_write_source (
    .clock    (clock),
    .reset    (reset),
    .io_flush (1'h0),
    .io_in    (io_regs_write_source),
    .io_out   (io_output_regs_write_source)
  );
  PipelineRegister_5 regs_write_address (
    .clock    (clock),
    .reset    (reset),
    .io_flush (1'h0),
    .io_in    (io_regs_write_address[4:0]),
    .io_out   (_regs_write_address_io_out)
  );
  PipelineRegister_2 instruction_address (
    .clock    (clock),
    .reset    (reset),
    .io_stall (1'h0),
    .io_flush (1'h0),
    .io_in    (io_instruction_address),
    .io_out   (io_output_instruction_address)
  );
  PipelineRegister_2 csr_read_data (
    .clock    (clock),
    .reset    (reset),
    .io_stall (1'h0),
    .io_flush (1'h0),
    .io_in    (io_csr_read_data),
    .io_out   (io_output_csr_read_data)
  );
  assign io_output_regs_write_address = {27'h0, _regs_write_address_io_out};
endmodule

module WriteBack(
  input  [31:0] io_instruction_address,
                io_alu_result,
                io_memory_read_data,
  input  [1:0]  io_regs_write_source,
  input  [31:0] io_csr_read_data,
  output [31:0] io_regs_write_data
);

  wire [3:0][31:0] _GEN =
    {{io_instruction_address + 32'h4},
     {io_csr_read_data},
     {io_memory_read_data},
     {io_alu_result}};
  assign io_regs_write_data = _GEN[io_regs_write_source];
endmodule

module Forwarding(
  input  [4:0] io_rs1_id,
               io_rs2_id,
               io_rs1_ex,
               io_rs2_ex,
               io_rd_mem,
  input        io_reg_write_enable_mem,
  input  [4:0] io_rd_wb,
  input        io_reg_write_enable_wb,
  output [1:0] io_reg1_forward_id,
               io_reg2_forward_id,
               io_reg1_forward_ex,
               io_reg2_forward_ex
);

  wire _T_20 = io_rd_mem == io_rs1_id;
  assign io_reg1_forward_id =
    io_reg_write_enable_mem & _T_20 & (|io_rd_mem)
      ? 2'h1
      : {io_reg_write_enable_mem & _T_20 & (|io_rd_mem), 1'h0};
  assign io_reg2_forward_id =
    io_reg_write_enable_mem & io_rd_mem == io_rs2_id & (|io_rd_mem)
      ? 2'h1
      : {io_reg_write_enable_wb & io_rd_wb == io_rs2_id & (|io_rd_wb), 1'h0};
  assign io_reg1_forward_ex =
    io_reg_write_enable_mem & io_rs1_ex == io_rd_mem & (|io_rd_mem)
      ? 2'h1
      : {io_reg_write_enable_wb & io_rs1_ex == io_rd_wb & (|io_rd_wb), 1'h0};
  assign io_reg2_forward_ex =
    io_reg_write_enable_mem & io_rs2_ex == io_rd_mem & (|io_rd_mem)
      ? 2'h1
      : {io_reg_write_enable_wb & io_rs2_ex == io_rd_wb & (|io_rd_wb), 1'h0};
endmodule

module CLINT(
  input  [31:0] io_interrupt_flag,
                io_instruction_id,
                io_instruction_address_if,
  input         io_jump_flag,
  input  [31:0] io_jump_address,
                io_csr_bundle_mstatus,
                io_csr_bundle_mepc,
                io_csr_bundle_mcause,
                io_csr_bundle_mtvec,
                io_csr_bundle_mie,
  output [31:0] io_id_interrupt_handler_address,
  output        io_id_interrupt_assert,
  output [31:0] io_csr_bundle_mstatus_write_data,
                io_csr_bundle_mepc_write_data,
                io_csr_bundle_mcause_write_data,
  output        io_csr_bundle_direct_write_enable
);

  wire _io_csr_bundle_mcause_write_data_T = io_instruction_id == 32'h73;
  wire _io_csr_bundle_mcause_write_data_T_2 = io_instruction_id == 32'h100073;
  wire _T_2 = _io_csr_bundle_mcause_write_data_T | _io_csr_bundle_mcause_write_data_T_2;
  wire _T_5 =
    (|io_interrupt_flag) & io_csr_bundle_mstatus[3]
    & (io_interrupt_flag[0] ? io_csr_bundle_mie[7] : io_csr_bundle_mie[11]);
  wire _T_6 = io_instruction_id == 32'h30200073;
  wire _GEN = _T_2 | _T_5;
  wire _GEN_0 = _GEN | _T_6;
  assign io_id_interrupt_handler_address =
    _GEN ? io_csr_bundle_mtvec : _T_6 ? io_csr_bundle_mepc : 32'h0;
  assign io_id_interrupt_assert = _GEN_0;
  assign io_csr_bundle_mstatus_write_data =
    _GEN
      ? {io_csr_bundle_mstatus[31:13],
         2'h3,
         io_csr_bundle_mstatus[10:8],
         io_csr_bundle_mstatus[3],
         io_csr_bundle_mstatus[6:4],
         1'h0,
         io_csr_bundle_mstatus[2:0]}
      : _T_6
          ? {io_csr_bundle_mstatus[31:13],
             2'h3,
             io_csr_bundle_mstatus[10:8],
             1'h1,
             io_csr_bundle_mstatus[6:4],
             io_csr_bundle_mstatus[7],
             io_csr_bundle_mstatus[2:0]}
          : io_csr_bundle_mstatus;
  assign io_csr_bundle_mepc_write_data =
    _GEN
      ? (io_jump_flag ? io_jump_address : io_instruction_address_if)
      : io_csr_bundle_mepc;
  assign io_csr_bundle_mcause_write_data =
    _T_2
      ? {28'h0,
         _io_csr_bundle_mcause_write_data_T_2
           ? 4'h3
           : {3'h5, _io_csr_bundle_mcause_write_data_T}}
      : _T_5
          ? (io_interrupt_flag[0] ? 32'h80000007 : 32'h8000000B)
          : io_csr_bundle_mcause;
  assign io_csr_bundle_direct_write_enable = _GEN_0;
endmodule

module CSR(
  input         clock,
                reset,
  input  [11:0] io_reg_read_address_id,
  input         io_reg_write_enable_ex,
  input  [11:0] io_reg_write_address_ex,
  input  [31:0] io_reg_write_data_ex,
                io_clint_access_bundle_mstatus_write_data,
                io_clint_access_bundle_mepc_write_data,
                io_clint_access_bundle_mcause_write_data,
  input         io_clint_access_bundle_direct_write_enable,
  output [31:0] io_id_reg_read_data,
                io_clint_access_bundle_mstatus,
                io_clint_access_bundle_mepc,
                io_clint_access_bundle_mcause,
                io_clint_access_bundle_mtvec,
                io_clint_access_bundle_mie
);

  reg  [31:0] mstatus;
  reg  [31:0] mie;
  reg  [31:0] mtvec;
  reg  [31:0] mscratch;
  reg  [31:0] mepc;
  reg  [31:0] mcause;
  reg  [63:0] cycles;
  wire        _T_2 = io_reg_write_address_ex == 12'h300;
  wire        _T_6 = io_reg_write_address_ex == 12'h305;
  wire        _T_4 = io_reg_write_address_ex == 12'h342;
  wire        _T_3 = io_reg_write_address_ex == 12'h341;
  wire        _T_5 = io_reg_write_address_ex == 12'h304;
  always @(posedge clock) begin
    if (reset) begin
      mstatus <= 32'h0;
      mie <= 32'h0;
      mtvec <= 32'h0;
      mscratch <= 32'h0;
      mepc <= 32'h0;
      mcause <= 32'h0;
      cycles <= 64'h0;
    end
    else begin
      if (io_clint_access_bundle_direct_write_enable) begin
        mstatus <= io_clint_access_bundle_mstatus_write_data;
        mepc <= io_clint_access_bundle_mepc_write_data;
        mcause <= io_clint_access_bundle_mcause_write_data;
      end
      else begin
        if (io_reg_write_enable_ex & _T_2)
          mstatus <= io_reg_write_data_ex;
        if (~io_reg_write_enable_ex | _T_2 | ~_T_3) begin
        end
        else
          mepc <= io_reg_write_data_ex;
        if (~io_reg_write_enable_ex | _T_2 | _T_3 | ~_T_4) begin
        end
        else
          mcause <= io_reg_write_data_ex;
      end
      if (io_reg_write_enable_ex & _T_5)
        mie <= io_reg_write_data_ex;
      if (~io_reg_write_enable_ex | _T_5 | ~_T_6) begin
      end
      else
        mtvec <= io_reg_write_data_ex;
      if (~io_reg_write_enable_ex | _T_5 | _T_6
          | io_reg_write_address_ex != 12'h340) begin
      end
      else
        mscratch <= io_reg_write_data_ex;
      cycles <= cycles + 64'h1;
    end
  end // always @(posedge)
  assign io_id_reg_read_data =
    io_reg_read_address_id == 12'hC80
      ? cycles[63:32]
      : io_reg_read_address_id == 12'hC00
          ? cycles[31:0]
          : io_reg_read_address_id == 12'h342
              ? mcause
              : io_reg_read_address_id == 12'h341
                  ? mepc
                  : io_reg_read_address_id == 12'h340
                      ? mscratch
                      : io_reg_read_address_id == 12'h305
                          ? mtvec
                          : io_reg_read_address_id == 12'h304
                              ? mie
                              : io_reg_read_address_id == 12'h300 ? mstatus : 32'h0;
  assign io_clint_access_bundle_mstatus =
    io_reg_write_enable_ex & _T_2 ? io_reg_write_data_ex : mstatus;
  assign io_clint_access_bundle_mepc =
    io_reg_write_enable_ex & _T_3 ? io_reg_write_data_ex : mepc;
  assign io_clint_access_bundle_mcause =
    io_reg_write_enable_ex & _T_4 ? io_reg_write_data_ex : mcause;
  assign io_clint_access_bundle_mtvec =
    io_reg_write_enable_ex & _T_6 ? io_reg_write_data_ex : mtvec;
  assign io_clint_access_bundle_mie =
    io_reg_write_enable_ex & _T_5 ? io_reg_write_data_ex : mie;
endmodule

module CPU(
  input         clock,
                reset,
  input  [31:0] io_instruction,
  input         io_instruction_valid,
  input  [31:0] io_memory_bundle_read_data,
                io_interrupt_flag,
  output [31:0] io_instruction_address,
                io_memory_bundle_address,
                io_memory_bundle_write_data,
  output        io_memory_bundle_write_enable
);

  wire [31:0] _csr_regs_io_id_reg_read_data;
  wire [31:0] _csr_regs_io_clint_access_bundle_mstatus;
  wire [31:0] _csr_regs_io_clint_access_bundle_mepc;
  wire [31:0] _csr_regs_io_clint_access_bundle_mcause;
  wire [31:0] _csr_regs_io_clint_access_bundle_mtvec;
  wire [31:0] _csr_regs_io_clint_access_bundle_mie;
  wire [31:0] _clint_io_id_interrupt_handler_address;
  wire        _clint_io_id_interrupt_assert;
  wire [31:0] _clint_io_csr_bundle_mstatus_write_data;
  wire [31:0] _clint_io_csr_bundle_mepc_write_data;
  wire [31:0] _clint_io_csr_bundle_mcause_write_data;
  wire        _clint_io_csr_bundle_direct_write_enable;
  wire [1:0]  _forwarding_io_reg1_forward_id;
  wire [1:0]  _forwarding_io_reg2_forward_id;
  wire [1:0]  _forwarding_io_reg1_forward_ex;
  wire [1:0]  _forwarding_io_reg2_forward_ex;
  wire [31:0] _wb_io_regs_write_data;
  wire [31:0] _mem2wb_io_output_instruction_address;
  wire [31:0] _mem2wb_io_output_alu_result;
  wire        _mem2wb_io_output_regs_write_enable;
  wire [1:0]  _mem2wb_io_output_regs_write_source;
  wire [31:0] _mem2wb_io_output_regs_write_address;
  wire [31:0] _mem2wb_io_output_memory_read_data;
  wire [31:0] _mem2wb_io_output_csr_read_data;
  wire [31:0] _mem_io_wb_memory_read_data;
  wire [31:0] _mem_io_forward_data;
  wire [31:0] _mem_io_bundle_address;
  wire        _ex2mem_io_output_regs_write_enable;
  wire [1:0]  _ex2mem_io_output_regs_write_source;
  wire [31:0] _ex2mem_io_output_regs_write_address;
  wire [31:0] _ex2mem_io_output_instruction_address;
  wire [31:0] _ex2mem_io_output_funct3;
  wire [31:0] _ex2mem_io_output_reg2_data;
  wire        _ex2mem_io_output_memory_read_enable;
  wire        _ex2mem_io_output_memory_write_enable;
  wire [31:0] _ex2mem_io_output_alu_result;
  wire [31:0] _ex2mem_io_output_csr_read_data;
  wire [31:0] _ex_io_mem_alu_result;
  wire [31:0] _ex_io_mem_reg2_data;
  wire [31:0] _ex_io_csr_write_data;
  wire [31:0] _id2ex_io_output_instruction;
  wire [31:0] _id2ex_io_output_instruction_address;
  wire [4:0]  _id2ex_io_output_regs_reg1_read_address;
  wire [4:0]  _id2ex_io_output_regs_reg2_read_address;
  wire        _id2ex_io_output_regs_write_enable;
  wire [4:0]  _id2ex_io_output_regs_write_address;
  wire [1:0]  _id2ex_io_output_regs_write_source;
  wire [31:0] _id2ex_io_output_reg1_data;
  wire [31:0] _id2ex_io_output_reg2_data;
  wire [31:0] _id2ex_io_output_immediate;
  wire        _id2ex_io_output_aluop1_source;
  wire        _id2ex_io_output_aluop2_source;
  wire        _id2ex_io_output_csr_write_enable;
  wire [11:0] _id2ex_io_output_csr_address;
  wire        _id2ex_io_output_memory_read_enable;
  wire        _id2ex_io_output_memory_write_enable;
  wire [31:0] _id2ex_io_output_csr_read_data;
  wire [4:0]  _id_io_regs_reg1_read_address;
  wire [4:0]  _id_io_regs_reg2_read_address;
  wire [31:0] _id_io_ex_immediate;
  wire        _id_io_ex_aluop1_source;
  wire        _id_io_ex_aluop2_source;
  wire        _id_io_ex_memory_read_enable;
  wire        _id_io_ex_memory_write_enable;
  wire [1:0]  _id_io_ex_reg_write_source;
  wire        _id_io_ex_reg_write_enable;
  wire [4:0]  _id_io_ex_reg_write_address;
  wire [11:0] _id_io_ex_csr_address;
  wire        _id_io_ex_csr_write_enable;
  wire        _id_io_ctrl_jump_instruction;
  wire        _id_io_clint_jump_flag;
  wire [31:0] _id_io_clint_jump_address;
  wire        _id_io_if_jump_flag;
  wire [31:0] _id_io_if_jump_address;
  wire [31:0] _if2id_io_output_instruction;
  wire [31:0] _if2id_io_output_instruction_address;
  wire [31:0] _if2id_io_output_interrupt_flag;
  wire [31:0] _inst_fetch_io_instruction_address;
  wire [31:0] _inst_fetch_io_id_instruction;
  wire [31:0] _regs_io_read_data1;
  wire [31:0] _regs_io_read_data2;
  wire        _ctrl_io_if_flush;
  wire        _ctrl_io_id_flush;
  wire        _ctrl_io_pc_stall;
  wire        _ctrl_io_if_stall;
  Control ctrl (
    .io_jump_flag              (_id_io_if_jump_flag),
    .io_jump_instruction_id    (_id_io_ctrl_jump_instruction),
    .io_rs1_id                 (_id_io_regs_reg1_read_address),
    .io_rs2_id                 (_id_io_regs_reg2_read_address),
    .io_memory_read_enable_ex  (_id2ex_io_output_memory_read_enable),
    .io_rd_ex                  (_id2ex_io_output_regs_write_address),
    .io_memory_read_enable_mem (_ex2mem_io_output_memory_read_enable),
    .io_rd_mem                 (_ex2mem_io_output_regs_write_address[4:0]),
    .io_if_flush               (_ctrl_io_if_flush),
    .io_id_flush               (_ctrl_io_id_flush),
    .io_pc_stall               (_ctrl_io_pc_stall),
    .io_if_stall               (_ctrl_io_if_stall)
  );
  RegisterFile regs (
    .clock            (clock),
    .reset            (reset),
    .io_write_enable  (_mem2wb_io_output_regs_write_enable),
    .io_write_address (_mem2wb_io_output_regs_write_address[4:0]),
    .io_write_data    (_wb_io_regs_write_data),
    .io_read_address1 (_id_io_regs_reg1_read_address),
    .io_read_address2 (_id_io_regs_reg2_read_address),
    .io_read_data1    (_regs_io_read_data1),
    .io_read_data2    (_regs_io_read_data2)
  );
  InstructionFetch inst_fetch (
    .clock                  (clock),
    .reset                  (reset),
    .io_stall_flag_ctrl     (_ctrl_io_pc_stall),
    .io_jump_flag_id        (_id_io_if_jump_flag),
    .io_jump_address_id     (_id_io_if_jump_address),
    .io_rom_instruction     (io_instruction),
    .io_instruction_valid   (io_instruction_valid),
    .io_instruction_address (_inst_fetch_io_instruction_address),
    .io_id_instruction      (_inst_fetch_io_id_instruction)
  );
  IF2ID if2id (
    .clock                         (clock),
    .reset                         (reset),
    .io_stall                      (_ctrl_io_if_stall),
    .io_flush                      (_ctrl_io_if_flush),
    .io_instruction                (_inst_fetch_io_id_instruction),
    .io_instruction_address        (_inst_fetch_io_instruction_address),
    .io_interrupt_flag             (io_interrupt_flag),
    .io_output_instruction         (_if2id_io_output_instruction),
    .io_output_instruction_address (_if2id_io_output_instruction_address),
    .io_output_interrupt_flag      (_if2id_io_output_interrupt_flag)
  );
  InstructionDecode id (
    .io_instruction               (_if2id_io_output_instruction),
    .io_instruction_address       (_if2id_io_output_instruction_address),
    .io_reg1_data                 (_regs_io_read_data1),
    .io_reg2_data                 (_regs_io_read_data2),
    .io_forward_from_mem          (_mem_io_forward_data),
    .io_forward_from_wb           (_wb_io_regs_write_data),
    .io_reg1_forward              (_forwarding_io_reg1_forward_id),
    .io_reg2_forward              (_forwarding_io_reg2_forward_id),
    .io_interrupt_assert          (_clint_io_id_interrupt_assert),
    .io_interrupt_handler_address (_clint_io_id_interrupt_handler_address),
    .io_regs_reg1_read_address    (_id_io_regs_reg1_read_address),
    .io_regs_reg2_read_address    (_id_io_regs_reg2_read_address),
    .io_ex_immediate              (_id_io_ex_immediate),
    .io_ex_aluop1_source          (_id_io_ex_aluop1_source),
    .io_ex_aluop2_source          (_id_io_ex_aluop2_source),
    .io_ex_memory_read_enable     (_id_io_ex_memory_read_enable),
    .io_ex_memory_write_enable    (_id_io_ex_memory_write_enable),
    .io_ex_reg_write_source       (_id_io_ex_reg_write_source),
    .io_ex_reg_write_enable       (_id_io_ex_reg_write_enable),
    .io_ex_reg_write_address      (_id_io_ex_reg_write_address),
    .io_ex_csr_address            (_id_io_ex_csr_address),
    .io_ex_csr_write_enable       (_id_io_ex_csr_write_enable),
    .io_ctrl_jump_instruction     (_id_io_ctrl_jump_instruction),
    .io_clint_jump_flag           (_id_io_clint_jump_flag),
    .io_clint_jump_address        (_id_io_clint_jump_address),
    .io_if_jump_flag              (_id_io_if_jump_flag),
    .io_if_jump_address           (_id_io_if_jump_address)
  );
  ID2EX id2ex (
    .clock                            (clock),
    .reset                            (reset),
    .io_flush                         (_ctrl_io_id_flush),
    .io_instruction                   (_if2id_io_output_instruction),
    .io_instruction_address           (_if2id_io_output_instruction_address),
    .io_regs_reg1_read_address        (_id_io_regs_reg1_read_address),
    .io_regs_reg2_read_address        (_id_io_regs_reg2_read_address),
    .io_regs_write_enable             (_id_io_ex_reg_write_enable),
    .io_regs_write_address            (_id_io_ex_reg_write_address),
    .io_regs_write_source             (_id_io_ex_reg_write_source),
    .io_reg1_data                     (_regs_io_read_data1),
    .io_reg2_data                     (_regs_io_read_data2),
    .io_immediate                     (_id_io_ex_immediate),
    .io_aluop1_source                 (_id_io_ex_aluop1_source),
    .io_aluop2_source                 (_id_io_ex_aluop2_source),
    .io_csr_write_enable              (_id_io_ex_csr_write_enable),
    .io_csr_address                   (_id_io_ex_csr_address),
    .io_memory_read_enable            (_id_io_ex_memory_read_enable),
    .io_memory_write_enable           (_id_io_ex_memory_write_enable),
    .io_csr_read_data                 (_csr_regs_io_id_reg_read_data),
    .io_output_instruction            (_id2ex_io_output_instruction),
    .io_output_instruction_address    (_id2ex_io_output_instruction_address),
    .io_output_regs_reg1_read_address (_id2ex_io_output_regs_reg1_read_address),
    .io_output_regs_reg2_read_address (_id2ex_io_output_regs_reg2_read_address),
    .io_output_regs_write_enable      (_id2ex_io_output_regs_write_enable),
    .io_output_regs_write_address     (_id2ex_io_output_regs_write_address),
    .io_output_regs_write_source      (_id2ex_io_output_regs_write_source),
    .io_output_reg1_data              (_id2ex_io_output_reg1_data),
    .io_output_reg2_data              (_id2ex_io_output_reg2_data),
    .io_output_immediate              (_id2ex_io_output_immediate),
    .io_output_aluop1_source          (_id2ex_io_output_aluop1_source),
    .io_output_aluop2_source          (_id2ex_io_output_aluop2_source),
    .io_output_csr_write_enable       (_id2ex_io_output_csr_write_enable),
    .io_output_csr_address            (_id2ex_io_output_csr_address),
    .io_output_memory_read_enable     (_id2ex_io_output_memory_read_enable),
    .io_output_memory_write_enable    (_id2ex_io_output_memory_write_enable),
    .io_output_csr_read_data          (_id2ex_io_output_csr_read_data)
  );
  Execute ex (
    .io_instruction         (_id2ex_io_output_instruction),
    .io_instruction_address (_id2ex_io_output_instruction_address),
    .io_reg1_data           (_id2ex_io_output_reg1_data),
    .io_reg2_data           (_id2ex_io_output_reg2_data),
    .io_immediate           (_id2ex_io_output_immediate),
    .io_aluop1_source       (_id2ex_io_output_aluop1_source),
    .io_aluop2_source       (_id2ex_io_output_aluop2_source),
    .io_csr_read_data       (_id2ex_io_output_csr_read_data),
    .io_forward_from_mem    (_mem_io_forward_data),
    .io_forward_from_wb     (_wb_io_regs_write_data),
    .io_reg1_forward        (_forwarding_io_reg1_forward_ex),
    .io_reg2_forward        (_forwarding_io_reg2_forward_ex),
    .io_mem_alu_result      (_ex_io_mem_alu_result),
    .io_mem_reg2_data       (_ex_io_mem_reg2_data),
    .io_csr_write_data      (_ex_io_csr_write_data)
  );
  EX2MEM ex2mem (
    .clock                         (clock),
    .reset                         (reset),
    .io_regs_write_enable          (_id2ex_io_output_regs_write_enable),
    .io_regs_write_source          (_id2ex_io_output_regs_write_source),
    .io_regs_write_address         ({27'h0, _id2ex_io_output_regs_write_address}),
    .io_instruction_address        (_id2ex_io_output_instruction_address),
    .io_funct3                     (_id2ex_io_output_instruction[14:12]),
    .io_reg2_data                  (_ex_io_mem_reg2_data),
    .io_memory_read_enable         (_id2ex_io_output_memory_read_enable),
    .io_memory_write_enable        (_id2ex_io_output_memory_write_enable),
    .io_alu_result                 (_ex_io_mem_alu_result),
    .io_csr_read_data              (_id2ex_io_output_csr_read_data),
    .io_output_regs_write_enable   (_ex2mem_io_output_regs_write_enable),
    .io_output_regs_write_source   (_ex2mem_io_output_regs_write_source),
    .io_output_regs_write_address  (_ex2mem_io_output_regs_write_address),
    .io_output_instruction_address (_ex2mem_io_output_instruction_address),
    .io_output_funct3              (_ex2mem_io_output_funct3),
    .io_output_reg2_data           (_ex2mem_io_output_reg2_data),
    .io_output_memory_read_enable  (_ex2mem_io_output_memory_read_enable),
    .io_output_memory_write_enable (_ex2mem_io_output_memory_write_enable),
    .io_output_alu_result          (_ex2mem_io_output_alu_result),
    .io_output_csr_read_data       (_ex2mem_io_output_csr_read_data)
  );
  MemoryAccess mem (
    .io_alu_result          (_ex2mem_io_output_alu_result),
    .io_reg2_data           (_ex2mem_io_output_reg2_data),
    .io_memory_read_enable  (_ex2mem_io_output_memory_read_enable),
    .io_memory_write_enable (_ex2mem_io_output_memory_write_enable),
    .io_funct3              (_ex2mem_io_output_funct3[2:0]),
    .io_regs_write_source   (_ex2mem_io_output_regs_write_source),
    .io_csr_read_data       (_ex2mem_io_output_csr_read_data),
    .io_bundle_read_data    (io_memory_bundle_read_data),
    .io_wb_memory_read_data (_mem_io_wb_memory_read_data),
    .io_forward_data        (_mem_io_forward_data),
    .io_bundle_address      (_mem_io_bundle_address),
    .io_bundle_write_data   (io_memory_bundle_write_data),
    .io_bundle_write_enable (io_memory_bundle_write_enable)
  );
  MEM2WB mem2wb (
    .clock                         (clock),
    .reset                         (reset),
    .io_instruction_address        (_ex2mem_io_output_instruction_address),
    .io_alu_result                 (_ex2mem_io_output_alu_result),
    .io_regs_write_enable          (_ex2mem_io_output_regs_write_enable),
    .io_regs_write_source          (_ex2mem_io_output_regs_write_source),
    .io_regs_write_address         (_ex2mem_io_output_regs_write_address),
    .io_memory_read_data           (_mem_io_wb_memory_read_data),
    .io_csr_read_data              (_ex2mem_io_output_csr_read_data),
    .io_output_instruction_address (_mem2wb_io_output_instruction_address),
    .io_output_alu_result          (_mem2wb_io_output_alu_result),
    .io_output_regs_write_enable   (_mem2wb_io_output_regs_write_enable),
    .io_output_regs_write_source   (_mem2wb_io_output_regs_write_source),
    .io_output_regs_write_address  (_mem2wb_io_output_regs_write_address),
    .io_output_memory_read_data    (_mem2wb_io_output_memory_read_data),
    .io_output_csr_read_data       (_mem2wb_io_output_csr_read_data)
  );
  WriteBack wb (
    .io_instruction_address (_mem2wb_io_output_instruction_address),
    .io_alu_result          (_mem2wb_io_output_alu_result),
    .io_memory_read_data    (_mem2wb_io_output_memory_read_data),
    .io_regs_write_source   (_mem2wb_io_output_regs_write_source),
    .io_csr_read_data       (_mem2wb_io_output_csr_read_data),
    .io_regs_write_data     (_wb_io_regs_write_data)
  );
  Forwarding forwarding (
    .io_rs1_id               (_id_io_regs_reg1_read_address),
    .io_rs2_id               (_id_io_regs_reg2_read_address),
    .io_rs1_ex               (_id2ex_io_output_regs_reg1_read_address),
    .io_rs2_ex               (_id2ex_io_output_regs_reg2_read_address),
    .io_rd_mem               (_ex2mem_io_output_regs_write_address[4:0]),
    .io_reg_write_enable_mem (_ex2mem_io_output_regs_write_enable),
    .io_rd_wb                (_mem2wb_io_output_regs_write_address[4:0]),
    .io_reg_write_enable_wb  (_mem2wb_io_output_regs_write_enable),
    .io_reg1_forward_id      (_forwarding_io_reg1_forward_id),
    .io_reg2_forward_id      (_forwarding_io_reg2_forward_id),
    .io_reg1_forward_ex      (_forwarding_io_reg1_forward_ex),
    .io_reg2_forward_ex      (_forwarding_io_reg2_forward_ex)
  );
  CLINT clint (
    .io_interrupt_flag                 (_if2id_io_output_interrupt_flag),
    .io_instruction_id                 (_if2id_io_output_instruction),
    .io_instruction_address_if         (_inst_fetch_io_instruction_address),
    .io_jump_flag                      (_id_io_clint_jump_flag),
    .io_jump_address                   (_id_io_clint_jump_address),
    .io_csr_bundle_mstatus             (_csr_regs_io_clint_access_bundle_mstatus),
    .io_csr_bundle_mepc                (_csr_regs_io_clint_access_bundle_mepc),
    .io_csr_bundle_mcause              (_csr_regs_io_clint_access_bundle_mcause),
    .io_csr_bundle_mtvec               (_csr_regs_io_clint_access_bundle_mtvec),
    .io_csr_bundle_mie                 (_csr_regs_io_clint_access_bundle_mie),
    .io_id_interrupt_handler_address   (_clint_io_id_interrupt_handler_address),
    .io_id_interrupt_assert            (_clint_io_id_interrupt_assert),
    .io_csr_bundle_mstatus_write_data  (_clint_io_csr_bundle_mstatus_write_data),
    .io_csr_bundle_mepc_write_data     (_clint_io_csr_bundle_mepc_write_data),
    .io_csr_bundle_mcause_write_data   (_clint_io_csr_bundle_mcause_write_data),
    .io_csr_bundle_direct_write_enable (_clint_io_csr_bundle_direct_write_enable)
  );
  CSR csr_regs (
    .clock                                      (clock),
    .reset                                      (reset),
    .io_reg_read_address_id                     (_id_io_ex_csr_address),
    .io_reg_write_enable_ex                     (_id2ex_io_output_csr_write_enable),
    .io_reg_write_address_ex                    (_id2ex_io_output_csr_address),
    .io_reg_write_data_ex                       (_ex_io_csr_write_data),
    .io_clint_access_bundle_mstatus_write_data  (_clint_io_csr_bundle_mstatus_write_data),
    .io_clint_access_bundle_mepc_write_data     (_clint_io_csr_bundle_mepc_write_data),
    .io_clint_access_bundle_mcause_write_data   (_clint_io_csr_bundle_mcause_write_data),
    .io_clint_access_bundle_direct_write_enable
      (_clint_io_csr_bundle_direct_write_enable),
    .io_id_reg_read_data                        (_csr_regs_io_id_reg_read_data),
    .io_clint_access_bundle_mstatus
      (_csr_regs_io_clint_access_bundle_mstatus),
    .io_clint_access_bundle_mepc                (_csr_regs_io_clint_access_bundle_mepc),
    .io_clint_access_bundle_mcause              (_csr_regs_io_clint_access_bundle_mcause),
    .io_clint_access_bundle_mtvec               (_csr_regs_io_clint_access_bundle_mtvec),
    .io_clint_access_bundle_mie                 (_csr_regs_io_clint_access_bundle_mie)
  );
  assign io_instruction_address = _inst_fetch_io_instruction_address;
  assign io_memory_bundle_address = {3'h0, _mem_io_bundle_address[28:0]};
endmodule

module CPU_1(
  input         clock,
                reset,
  input  [31:0] io_instruction,
  input         io_instruction_valid,
  input  [31:0] io_memory_bundle_read_data,
                io_interrupt_flag,
  output [31:0] io_instruction_address,
                io_memory_bundle_address,
                io_memory_bundle_write_data,
  output        io_memory_bundle_write_enable
);

  CPU cpu (
    .clock                         (clock),
    .reset                         (reset),
    .io_instruction                (io_instruction),
    .io_instruction_valid          (io_instruction_valid),
    .io_memory_bundle_read_data    (io_memory_bundle_read_data),
    .io_interrupt_flag             (io_interrupt_flag),
    .io_instruction_address        (io_instruction_address),
    .io_memory_bundle_address      (io_memory_bundle_address),
    .io_memory_bundle_write_data   (io_memory_bundle_write_data),
    .io_memory_bundle_write_enable (io_memory_bundle_write_enable)
  );
endmodule

module MyCPUWrapper(
  input         clock,
                reset,
  input  [31:0] io_bus_rdata,
  input         io_bus_ready,
                io_irq_external,
  output [31:0] io_bus_addr,
                io_bus_wdata,
  output        io_bus_wen,
                io_bus_ren
);

  wire [31:0] _cpu_io_instruction_address;
  wire [31:0] _cpu_io_memory_bundle_address;
  wire [31:0] _cpu_io_memory_bundle_write_data;
  wire        _cpu_io_memory_bundle_write_enable;
  wire        dmem_access_req =
    _cpu_io_memory_bundle_write_enable | (|_cpu_io_memory_bundle_address);
  CPU_1 cpu (
    .clock                         (clock),
    .reset                         (reset),
    .io_instruction                (io_bus_rdata),
    .io_instruction_valid          (io_bus_ready & ~dmem_access_req),
    .io_memory_bundle_read_data    (io_bus_rdata),
    .io_interrupt_flag             ({31'h0, io_irq_external}),
    .io_instruction_address        (_cpu_io_instruction_address),
    .io_memory_bundle_address      (_cpu_io_memory_bundle_address),
    .io_memory_bundle_write_data   (_cpu_io_memory_bundle_write_data),
    .io_memory_bundle_write_enable (_cpu_io_memory_bundle_write_enable)
  );
  assign io_bus_addr =
    dmem_access_req ? _cpu_io_memory_bundle_address : _cpu_io_instruction_address;
  assign io_bus_wdata = dmem_access_req ? _cpu_io_memory_bundle_write_data : 32'h0;
  assign io_bus_wen = dmem_access_req & _cpu_io_memory_bundle_write_enable;
  assign io_bus_ren = ~dmem_access_req | ~_cpu_io_memory_bundle_write_enable;
endmodule

module SimpleAddressDecoder(
  input  [31:0] io_cpu_addr,
                io_cpu_wdata,
  input         io_cpu_wen,
                io_cpu_ren,
  input  [31:0] io_compact_rdata,
                io_bitnet_rdata,
                io_uart_rdata,
                io_lcd_rdata,
  input         io_lcd_ready,
  input  [31:0] io_gpio_rdata,
  output [31:0] io_cpu_rdata,
  output        io_cpu_ready,
  output [31:0] io_compact_addr,
                io_compact_wdata,
  output        io_compact_wen,
                io_compact_ren,
                io_compact_valid,
  output [31:0] io_bitnet_addr,
                io_bitnet_wdata,
  output        io_bitnet_wen,
                io_bitnet_ren,
                io_bitnet_valid,
  output [31:0] io_uart_addr,
                io_uart_wdata,
  output        io_uart_wen,
                io_uart_ren,
                io_uart_valid,
  output [31:0] io_lcd_addr,
                io_lcd_wdata,
  output        io_lcd_wen,
                io_lcd_ren,
                io_lcd_valid,
  output [31:0] io_gpio_wdata,
  output        io_gpio_wen,
                io_gpio_ren,
                io_gpio_valid
);

  wire sel_compact = (|(io_cpu_addr[31:28])) & io_cpu_addr < 32'h10001000;
  wire sel_bitnet = io_cpu_addr > 32'h10000FFF & io_cpu_addr < 32'h10002000;
  wire sel_uart = (|(io_cpu_addr[31:29])) & io_cpu_addr < 32'h20010000;
  wire sel_lcd = io_cpu_addr > 32'h2000FFFF & io_cpu_addr < 32'h20020000;
  wire sel_gpio = io_cpu_addr > 32'h2001FFFF & io_cpu_addr < 32'h20030000;
  assign io_cpu_rdata =
    sel_compact
      ? io_compact_rdata
      : sel_bitnet
          ? io_bitnet_rdata
          : sel_uart
              ? io_uart_rdata
              : sel_lcd ? io_lcd_rdata : sel_gpio ? io_gpio_rdata : 32'h0;
  assign io_cpu_ready = sel_compact | sel_bitnet | sel_uart | ~sel_lcd | io_lcd_ready;
  assign io_compact_addr = io_cpu_addr;
  assign io_compact_wdata = io_cpu_wdata;
  assign io_compact_wen = io_cpu_wen & sel_compact;
  assign io_compact_ren = io_cpu_ren & sel_compact;
  assign io_compact_valid = sel_compact;
  assign io_bitnet_addr = io_cpu_addr;
  assign io_bitnet_wdata = io_cpu_wdata;
  assign io_bitnet_wen = io_cpu_wen & sel_bitnet;
  assign io_bitnet_ren = io_cpu_ren & sel_bitnet;
  assign io_bitnet_valid = sel_bitnet;
  assign io_uart_addr = io_cpu_addr;
  assign io_uart_wdata = io_cpu_wdata;
  assign io_uart_wen = io_cpu_wen & sel_uart;
  assign io_uart_ren = io_cpu_ren & sel_uart;
  assign io_uart_valid = sel_uart;
  assign io_lcd_addr = io_cpu_addr;
  assign io_lcd_wdata = io_cpu_wdata;
  assign io_lcd_wen = io_cpu_wen & sel_lcd;
  assign io_lcd_ren = io_cpu_ren & sel_lcd;
  assign io_lcd_valid = sel_lcd;
  assign io_gpio_wdata = io_cpu_wdata;
  assign io_gpio_wen = io_cpu_wen & sel_gpio;
  assign io_gpio_ren = io_cpu_ren & sel_gpio;
  assign io_gpio_valid = sel_gpio;
endmodule

module SimpleCompactAccel(
  input         clock,
                reset,
  input  [31:0] io_reg_addr,
                io_reg_wdata,
  input         io_reg_wen,
                io_reg_ren,
                io_reg_valid,
  output [31:0] io_reg_rdata,
  output        io_irq
);

  wire [31:0] _matrixC_ext_R0_data;
  wire [31:0] _matrixB_ext_R0_data;
  wire [31:0] _matrixA_ext_R0_data;
  reg  [31:0] ctrl;
  reg  [31:0] status;
  reg  [31:0] matrixSize;
  reg  [31:0] perfCycles;
  reg  [1:0]  state;
  reg  [3:0]  i;
  reg  [3:0]  j;
  reg  [3:0]  k;
  reg  [31:0] accumulator;
  wire        _T = state == 2'h0;
  wire        _T_2 = state == 2'h1;
  wire [5:0]  _GEN = {i[2:0], 3'h0};
  wire [5:0]  _GEN_0 = {2'h0, j};
  wire        _GEN_1 = ~_T & _T_2;
  wire [31:0] _GEN_2 = accumulator + _matrixA_ext_R0_data * _matrixB_ext_R0_data;
  wire [31:0] _T_4 = matrixSize - 32'h1;
  wire        _T_5 = {28'h0, k} < _T_4;
  wire        _T_13 = state == 2'h2;
  wire        _GEN_3 = _T | _T_2;
  wire        _GEN_4 = io_reg_valid & io_reg_wen;
  wire        _T_30 = io_reg_addr[11:0] > 12'h4FF & io_reg_addr[11:0] < 12'h600;
  wire        _GEN_5 = io_reg_valid & io_reg_ren;
  always @(posedge clock) begin
    if (reset) begin
      ctrl <= 32'h0;
      status <= 32'h0;
      matrixSize <= 32'h8;
      perfCycles <= 32'h0;
      state <= 2'h0;
      i <= 4'h0;
      j <= 4'h0;
      k <= 4'h0;
      accumulator <= 32'h0;
    end
    else begin
      automatic logic             _T_9;
      automatic logic             _T_12;
      automatic logic [3:0][31:0] _GEN_6 = {{status}, {32'h2}, {32'h1}, {32'h0}};
      automatic logic [3:0][1:0]  _GEN_7;
      _T_9 = {28'h0, j} < _T_4;
      _T_12 = {28'h0, i} < _T_4;
      if (io_reg_valid & io_reg_wen & ~(|(io_reg_addr[11:0])))
        ctrl <= io_reg_wdata;
      else if (_GEN_3 | ~_T_13) begin
      end
      else
        ctrl <= 32'h0;
      status <= _GEN_6[state];
      if (_GEN_4 & (|(io_reg_addr[11:0])) & io_reg_addr[11:0] == 12'h1C)
        matrixSize <= io_reg_wdata;
      if (_T) begin
        if (ctrl[0]) begin
          perfCycles <= 32'h0;
          i <= 4'h0;
          j <= 4'h0;
          k <= 4'h0;
          accumulator <= 32'h0;
        end
      end
      else begin
        if (_T_2) begin
          perfCycles <= perfCycles + 32'h1;
          if (_T_5) begin
            k <= k + 4'h1;
            accumulator <= _GEN_2;
          end
          else begin
            k <= 4'h0;
            accumulator <= 32'h0;
          end
        end
        if (~_T_2 | _T_5 | _T_9 | ~_T_12) begin
        end
        else
          i <= i + 4'h1;
        if (~_T_2 | _T_5) begin
        end
        else if (_T_9)
          j <= j + 4'h1;
        else
          j <= 4'h0;
      end
      _GEN_7 =
        {{state}, {2'h0}, {_T_5 | _T_9 | _T_12 ? state : 2'h2}, {ctrl[0] ? 2'h1 : state}};
      state <= _GEN_7[state];
    end
  end // always @(posedge)
  matrixA_combMem matrixA_ext (
    .R0_addr (_GEN + {2'h0, k}),
    .R0_en   (_GEN_1),
    .R0_clk  (clock),
    .W0_addr (io_reg_addr[7:2]),
    .W0_en   (_GEN_4 & (|(io_reg_addr[11:8])) & io_reg_addr[11:0] < 12'h200),
    .W0_clk  (clock),
    .W0_data (io_reg_wdata),
    .R0_data (_matrixA_ext_R0_data)
  );
  matrixA_combMem matrixB_ext (
    .R0_addr ({k[2:0], 3'h0} + _GEN_0),
    .R0_en   (_GEN_1),
    .R0_clk  (clock),
    .W0_addr (io_reg_addr[7:2]),
    .W0_en   (_GEN_4 & io_reg_addr[11:0] > 12'h2FF & io_reg_addr[11:0] < 12'h400),
    .W0_clk  (clock),
    .W0_data (io_reg_wdata),
    .R0_data (_matrixB_ext_R0_data)
  );
  matrixA_combMem matrixC_ext (
    .R0_addr (io_reg_addr[7:2]),
    .R0_en   (_GEN_5 & _T_30),
    .R0_clk  (clock),
    .W0_addr (_GEN + _GEN_0),
    .W0_en   (~_T & _T_2 & ~_T_5),
    .W0_clk  (clock),
    .W0_data (_GEN_2),
    .R0_data (_matrixC_ext_R0_data)
  );
  assign io_reg_rdata =
    _GEN_5
      ? (_T_30
           ? _matrixC_ext_R0_data
           : (|(io_reg_addr[11:0]))
               ? (io_reg_addr[11:0] == 12'h4
                    ? status
                    : io_reg_addr[11:0] == 12'h1C
                        ? matrixSize
                        : io_reg_addr[11:0] == 12'h28 ? perfCycles : 32'h0)
               : ctrl)
      : 32'h0;
  assign io_irq = ~_GEN_3 & _T_13;
endmodule

module SimpleBitNetAccel(
  input         clock,
                reset,
  input  [31:0] io_reg_addr,
                io_reg_wdata,
  input         io_reg_wen,
                io_reg_ren,
                io_reg_valid,
  output [31:0] io_reg_rdata,
  output        io_irq
);

  wire [31:0] _result_ext_R0_data;
  wire [1:0]  _weight_ext_R0_data;
  wire [1:0]  _weight_ext_R1_data;
  wire [31:0] _activation_ext_R0_data;
  wire [31:0] _activation_ext_R1_data;
  reg  [31:0] ctrl;
  reg  [31:0] status;
  reg  [31:0] config_0;
  reg  [31:0] matrixSize;
  reg  [31:0] perfCycles;
  reg  [31:0] sparsitySkipped;
  reg  [31:0] errorCode;
  reg  [1:0]  state;
  reg  [7:0]  i;
  reg  [7:0]  j;
  reg  [7:0]  k;
  reg  [31:0] accumulator;
  reg  [2:0]  finalizeCounter;
  wire        _T = state == 2'h0;
  wire        _T_5 = state == 2'h1;
  wire [7:0]  _GEN = {i[3:0], 4'h0};
  wire        _GEN_0 = ~_T & _T_5;
  wire        _T_6 = _weight_ext_R1_data == 2'h1;
  wire [31:0] _newAccum_T_1 = accumulator + _activation_ext_R0_data;
  wire        _T_7 = _weight_ext_R1_data == 2'h2;
  wire [31:0] _newAccum_T_4 = accumulator - _activation_ext_R0_data;
  wire [31:0] _T_9 = matrixSize - 32'h1;
  wire        _T_10 = {24'h0, k} < _T_9;
  wire        _T_15 = state == 2'h2;
  wire        _GEN_1 = io_reg_valid & io_reg_wen;
  wire [9:0]  _GEN_2 = io_reg_addr[9:0] - 10'h100;
  wire [9:0]  _GEN_3 = io_reg_addr[9:0] + 10'h100;
  wire        _T_45 = (|(io_reg_addr[11:8])) & io_reg_addr[11:0] < 12'h300;
  wire        _GEN_4 = io_reg_valid & io_reg_ren;
  wire        _T_48 = io_reg_addr[11:0] > 12'h2FF & io_reg_addr[11:0] < 12'h500;
  wire        _T_54 = io_reg_addr[11:0] > 12'h4FF & io_reg_addr[11:0] < 12'h900;
  always @(posedge clock) begin
    if (reset) begin
      ctrl <= 32'h0;
      status <= 32'h0;
      config_0 <= 32'h0;
      matrixSize <= 32'h8;
      perfCycles <= 32'h0;
      sparsitySkipped <= 32'h0;
      errorCode <= 32'h0;
      state <= 2'h0;
      i <= 8'h0;
      j <= 8'h0;
      k <= 8'h0;
      accumulator <= 32'h0;
      finalizeCounter <= 3'h0;
    end
    else begin
      automatic logic             _T_4;
      automatic logic             _GEN_5;
      automatic logic [31:0]      _GEN_6;
      automatic logic             isLastElement;
      automatic logic             _T_19 = io_reg_addr[11:0] == 12'h1C;
      automatic logic [3:0][31:0] _GEN_7;
      automatic logic [3:0][1:0]  _GEN_8;
      _T_4 = matrixSize < 32'h2 | matrixSize > 32'h8;
      _GEN_5 = ~(ctrl[0]) | _T_4;
      _GEN_6 = {24'h0, j};
      isLastElement = {24'h0, i} == _T_9 & _GEN_6 == _T_9;
      if (io_reg_valid & io_reg_wen & ~(|(io_reg_addr[11:0])))
        ctrl <= io_reg_wdata;
      else if (_T | _T_5 | _T_15 | ~(&state)) begin
      end
      else
        ctrl <= 32'h0;
      _GEN_7 =
        {{_T_15 | ~(&state) ? status : 32'h2},
         {status},
         {32'h1},
         {ctrl[0] & _T_4 ? 32'h3 : 32'h0}};
      status <= _GEN_7[state];
      if (~_GEN_1 | ~(|(io_reg_addr[11:0])) | _T_19 | io_reg_addr[11:0] != 12'h20) begin
      end
      else
        config_0 <= io_reg_wdata;
      if (_GEN_1 & (|(io_reg_addr[11:0])) & _T_19) begin
        if ((|(io_reg_wdata[31:1])) & io_reg_wdata < 32'h9)
          matrixSize <= io_reg_wdata;
        else
          matrixSize <= 32'h8;
      end
      if (_T) begin
        if (_GEN_5) begin
        end
        else begin
          perfCycles <= 32'h0;
          sparsitySkipped <= 32'h0;
          i <= 8'h0;
          j <= 8'h0;
          k <= 8'h0;
          accumulator <= 32'h0;
          finalizeCounter <= 3'h0;
        end
      end
      else begin
        automatic logic _T_14;
        _T_14 = _GEN_6 < _T_9;
        if (_T_5) begin
          perfCycles <= perfCycles + 32'h1;
          if (_T_10) begin
            k <= k + 8'h1;
            if (_T_6)
              accumulator <= _newAccum_T_1;
            else if (_T_7)
              accumulator <= _newAccum_T_4;
          end
          else if (~isLastElement) begin
            k <= 8'h0;
            accumulator <= 32'h0;
          end
        end
        if (~_T_5 | _T_6 | _T_7) begin
        end
        else
          sparsitySkipped <= sparsitySkipped + 32'h1;
        if (~_T_5 | _T_10 | isLastElement | _T_14) begin
        end
        else
          i <= i + 8'h1;
        if (~_T_5 | _T_10 | isLastElement) begin
        end
        else if (_T_14)
          j <= j + 8'h1;
        else
          j <= 8'h0;
        if (_T_5 | ~_T_15) begin
        end
        else
          finalizeCounter <= finalizeCounter + 3'h1;
      end
      if (_T & ctrl[0])
        errorCode <= {31'h0, _T_4};
      _GEN_8 =
        {{2'h0},
         {finalizeCounter > 3'h2 ? 2'h3 : state},
         {_T_10 | ~isLastElement ? state : 2'h2},
         {_GEN_5 ? state : 2'h1}};
      state <= _GEN_8[state];
    end
  end // always @(posedge)
  activation_combMem activation_ext (
    .R0_addr (_GEN + k),
    .R0_en   (_GEN_0),
    .R0_clk  (clock),
    .R1_addr (_GEN_2[9:2]),
    .R1_en   (_GEN_4 & _T_45),
    .R1_clk  (clock),
    .W0_addr (_GEN_2[9:2]),
    .W0_en   (_GEN_1 & (|(io_reg_addr[11:8])) & io_reg_addr[11:0] < 12'h300),
    .W0_clk  (clock),
    .W0_data (io_reg_wdata),
    .R0_data (_activation_ext_R0_data),
    .R1_data (_activation_ext_R1_data)
  );
  weight_combMem weight_ext (
    .R0_addr (_GEN_3[9:2]),
    .R0_en   (_GEN_4 & _T_48),
    .R0_clk  (clock),
    .R1_addr ({k[3:0], 4'h0} + j),
    .R1_en   (_GEN_0),
    .R1_clk  (clock),
    .W0_addr (_GEN_3[9:2]),
    .W0_en   (_GEN_1 & io_reg_addr[11:0] > 12'h2FF & io_reg_addr[11:0] < 12'h500),
    .W0_clk  (clock),
    .W0_data
      (io_reg_wdata == 32'h0
         ? 2'h0
         : io_reg_wdata == 32'h1 | ~((&io_reg_wdata) | $signed(io_reg_wdata) < 32'sh1)
             ? 2'h1
             : 2'h2),
    .R0_data (_weight_ext_R0_data),
    .R1_data (_weight_ext_R1_data)
  );
  result_combMem result_ext (
    .R0_addr (_GEN_2[9:2]),
    .R0_en   (_GEN_4 & _T_54),
    .R0_clk  (clock),
    .W0_addr (_GEN + j),
    .W0_en   (~_T & _T_5 & ~_T_10),
    .W0_clk  (clock),
    .W0_data (_T_6 ? _newAccum_T_1 : _T_7 ? _newAccum_T_4 : accumulator),
    .R0_data (_result_ext_R0_data)
  );
  assign io_reg_rdata =
    _GEN_4
      ? (_T_54
           ? _result_ext_R0_data
           : _T_48
               ? (_weight_ext_R0_data == 2'h0
                    ? 32'h0
                    : _weight_ext_R0_data == 2'h1
                        ? 32'h1
                        : {32{_weight_ext_R0_data == 2'h2}})
               : _T_45
                   ? _activation_ext_R1_data
                   : (|(io_reg_addr[11:0]))
                       ? (io_reg_addr[11:0] == 12'h4
                            ? status
                            : io_reg_addr[11:0] == 12'h1C
                                ? matrixSize
                                : io_reg_addr[11:0] == 12'h20
                                    ? config_0
                                    : io_reg_addr[11:0] == 12'h28
                                        ? perfCycles
                                        : io_reg_addr[11:0] == 12'h2C
                                            ? sparsitySkipped
                                            : io_reg_addr[11:0] == 12'h30
                                                ? errorCode
                                                : 32'h0)
                       : ctrl)
      : 32'h0;
  assign io_irq = ~(_T | _T_5 | _T_15) & (&state);
endmodule

module Queue(
  input        clock,
               reset,
               io_enq_valid,
  input  [7:0] io_enq_bits,
  input        io_deq_ready,
  output       io_enq_ready,
               io_deq_valid,
  output [7:0] io_deq_bits
);

  reg  [3:0] enq_ptr_value;
  reg  [3:0] deq_ptr_value;
  reg        maybe_full;
  wire       ptr_match = enq_ptr_value == deq_ptr_value;
  wire       empty = ptr_match & ~maybe_full;
  wire       full = ptr_match & maybe_full;
  wire       do_enq = ~full & io_enq_valid;
  always @(posedge clock) begin
    if (reset) begin
      enq_ptr_value <= 4'h0;
      deq_ptr_value <= 4'h0;
      maybe_full <= 1'h0;
    end
    else begin
      automatic logic do_deq = io_deq_ready & ~empty;
      if (do_enq)
        enq_ptr_value <= enq_ptr_value + 4'h1;
      if (do_deq)
        deq_ptr_value <= deq_ptr_value + 4'h1;
      if (do_enq != do_deq)
        maybe_full <= do_enq;
    end
  end // always @(posedge)
  ram_combMem ram_ext (
    .R0_addr (deq_ptr_value),
    .R0_en   (1'h1),
    .R0_clk  (clock),
    .W0_addr (enq_ptr_value),
    .W0_en   (do_enq),
    .W0_clk  (clock),
    .W0_data (io_enq_bits),
    .R0_data (io_deq_bits)
  );
  assign io_enq_ready = ~full;
  assign io_deq_valid = ~empty;
endmodule

module RealUART(
  input         clock,
                reset,
  input  [31:0] io_addr,
                io_wdata,
  input         io_wen,
                io_ren,
                io_valid,
                io_rx,
  output [31:0] io_rdata,
  output        io_tx,
                io_tx_irq,
                io_rx_irq
);

  wire        _rxFifo_io_deq_valid;
  wire [7:0]  _rxFifo_io_deq_bits;
  wire        _txFifo_io_enq_ready;
  wire        _txFifo_io_deq_valid;
  wire [7:0]  _txFifo_io_deq_bits;
  reg  [31:0] control;
  reg  [31:0] baudDiv;
  reg  [31:0] baudCounter;
  wire [31:0] _T_1 = baudDiv - 32'h1;
  wire        baudTick = baudCounter >= _T_1;
  reg  [1:0]  txState;
  reg  [3:0]  txBitCounter;
  reg  [7:0]  txShiftReg;
  reg         txReg;
  wire        _T_3 = txState == 2'h0;
  wire        _T_5 = control[0] & _txFifo_io_deq_valid & baudTick;
  reg  [1:0]  rxState;
  reg  [3:0]  rxBitCounter;
  reg  [7:0]  rxShiftReg;
  reg         rxSync_REG;
  reg         rxSync;
  reg  [31:0] rxBaudCounter;
  wire        rxBaudTick = rxBaudCounter >= _T_1;
  wire        _T_15 = rxState == 2'h0;
  wire        _T_18 = rxState == 2'h1;
  wire        _T_20 = rxState == 2'h2;
  wire        _GEN = (&rxState) & rxBaudTick;
  wire        _GEN_0 = _T_15 | _T_18 | _T_20;
  wire        _GEN_1 = io_valid & io_wen;
  wire        _GEN_2 = io_valid & io_ren;
  always @(posedge clock) begin
    if (reset) begin
      control <= 32'h0;
      baudDiv <= 32'h364;
      baudCounter <= 32'h0;
      txState <= 2'h0;
      txBitCounter <= 4'h0;
      txShiftReg <= 8'h0;
      txReg <= 1'h1;
      rxState <= 2'h0;
      rxBitCounter <= 4'h0;
      rxShiftReg <= 8'h0;
      rxBaudCounter <= 32'h0;
    end
    else begin
      automatic logic            _T_6;
      automatic logic            _T_7;
      automatic logic            _T_14;
      automatic logic            rxHalfBaudTick;
      automatic logic            _T_17 = control[1] & ~rxSync;
      automatic logic            _T_24 = io_addr[7:0] == 8'h8;
      automatic logic [3:0][1:0] _GEN_3 =
        {{(&txState) & baudTick ? 2'h0 : txState},
         {baudTick & txBitCounter == 4'h7 ? 2'h3 : txState},
         {baudTick ? 2'h2 : txState},
         {_T_5 ? 2'h1 : txState}};
      automatic logic [3:0][1:0] _GEN_4;
      _T_6 = txState == 2'h1;
      _T_7 = txState == 2'h2;
      _T_14 = rxBaudCounter == {1'h0, baudDiv[31:1]};
      rxHalfBaudTick = ~rxBaudTick & _T_14;
      if (_GEN_1 & (|(io_addr[7:0])) & _T_24)
        control <= io_wdata;
      if (~_GEN_1 | ~(|(io_addr[7:0])) | _T_24 | io_addr[7:0] != 8'hC) begin
      end
      else
        baudDiv <= io_wdata;
      if (baudTick)
        baudCounter <= 32'h0;
      else
        baudCounter <= baudCounter + 32'h1;
      txState <= _GEN_3[txState];
      if (_T_3) begin
        if (_T_5) begin
          txBitCounter <= 4'h0;
          txShiftReg <= _txFifo_io_deq_bits;
        end
      end
      else if (_T_6 | ~(_T_7 & baudTick)) begin
      end
      else begin
        txBitCounter <= txBitCounter + 4'h1;
        txShiftReg <= {1'h0, txShiftReg[7:1]};
      end
      txReg <= _T_3 | ~_T_6 & (_T_7 ? txShiftReg[0] : (&txState) | txReg);
      _GEN_4 =
        {{_GEN ? 2'h0 : rxState},
         {rxBaudTick & rxBitCounter == 4'h7 ? 2'h3 : rxState},
         {rxHalfBaudTick ? {~rxSync, 1'h0} : rxState},
         {_T_17 ? 2'h1 : rxState}};
      rxState <= _GEN_4[rxState];
      if (~_T_15) begin
        if (_T_18) begin
          if (rxHalfBaudTick & ~rxSync) begin
            rxBitCounter <= 4'h0;
            rxShiftReg <= 8'h0;
          end
        end
        else if (_T_20 & rxBaudTick) begin
          rxBitCounter <= rxBitCounter + 4'h1;
          rxShiftReg <= {rxSync, rxShiftReg[7:1]};
        end
      end
      if (_T_15 & _T_17 | rxBaudTick)
        rxBaudCounter <= 32'h0;
      else if (_T_14)
        rxBaudCounter <= rxBaudCounter + 32'h1;
      else
        rxBaudCounter <= rxBaudCounter + 32'h1;
    end
    rxSync_REG <= io_rx;
    rxSync <= rxSync_REG;
  end // always @(posedge)
  Queue txFifo (
    .clock        (clock),
    .reset        (reset),
    .io_enq_valid (_GEN_1 & ~(|(io_addr[7:0]))),
    .io_enq_bits  (io_valid & io_wen & ~(|(io_addr[7:0])) ? io_wdata[7:0] : 8'h0),
    .io_deq_ready (_T_3 & _T_5),
    .io_enq_ready (_txFifo_io_enq_ready),
    .io_deq_valid (_txFifo_io_deq_valid),
    .io_deq_bits  (_txFifo_io_deq_bits)
  );
  Queue rxFifo (
    .clock        (clock),
    .reset        (reset),
    .io_enq_valid (~_GEN_0 & _GEN & rxSync),
    .io_enq_bits  (_GEN_0 | ~((&rxState) & rxBaudTick & rxSync) ? 8'h0 : rxShiftReg),
    .io_deq_ready (_GEN_2 & ~(|(io_addr[7:0]))),
    .io_enq_ready (/* unused */),
    .io_deq_valid (_rxFifo_io_deq_valid),
    .io_deq_bits  (_rxFifo_io_deq_bits)
  );
  assign io_rdata =
    _GEN_2
      ? ((|(io_addr[7:0]))
           ? (io_addr[7:0] == 8'h4
                ? {28'h0,
                   ~_rxFifo_io_deq_valid,
                   ~_txFifo_io_enq_ready,
                   _rxFifo_io_deq_valid,
                   |txState}
                : io_addr[7:0] == 8'h8 ? control : io_addr[7:0] == 8'hC ? baudDiv : 32'h0)
           : {24'h0, _rxFifo_io_deq_bits})
      : 32'h0;
  assign io_tx = txReg;
  assign io_tx_irq = control[2] & _txFifo_io_enq_ready;
  assign io_rx_irq = control[3] & _rxFifo_io_deq_valid;
endmodule

module SimpleUARTWrapper(
  input         clock,
                reset,
  input  [31:0] io_reg_addr,
                io_reg_wdata,
  input         io_reg_wen,
                io_reg_ren,
                io_reg_valid,
                io_rx,
  output [31:0] io_reg_rdata,
  output        io_tx,
                io_tx_irq,
                io_rx_irq
);

  RealUART uart (
    .clock     (clock),
    .reset     (reset),
    .io_addr   (io_reg_addr),
    .io_wdata  (io_reg_wdata),
    .io_wen    (io_reg_wen),
    .io_ren    (io_reg_ren),
    .io_valid  (io_reg_valid),
    .io_rx     (io_rx),
    .io_rdata  (io_reg_rdata),
    .io_tx     (io_tx),
    .io_tx_irq (io_tx_irq),
    .io_rx_irq (io_rx_irq)
  );
endmodule

module TFTLCD(
  input         clock,
                reset,
  input  [31:0] io_addr,
                io_wdata,
  input         io_wen,
                io_ren,
                io_valid,
  output [31:0] io_rdata,
  output        io_ready,
                io_spi_clk,
                io_spi_mosi,
                io_spi_cs,
                io_spi_dc,
                io_spi_rst,
                io_backlight
);

  reg  [31:0] control;
  reg  [7:0]  spiCounter;
  reg         spiClkReg;
  reg         state;
  reg  [7:0]  spiShiftReg;
  reg  [2:0]  spiBitCounter;
  reg         spiDC;
  reg         spiCS;
  reg         busy;
  reg  [7:0]  txData;
  reg         txValid;
  reg         txIsData;
  wire        _T_9 = io_valid & ~busy;
  always @(posedge clock) begin
    if (reset) begin
      control <= 32'h0;
      spiCounter <= 8'h0;
      spiClkReg <= 1'h0;
      state <= 1'h0;
      spiShiftReg <= 8'h0;
      spiBitCounter <= 3'h0;
      spiDC <= 1'h0;
      spiCS <= 1'h1;
      busy <= 1'h0;
      txData <= 8'h0;
      txValid <= 1'h0;
      txIsData <= 1'h0;
    end
    else begin
      automatic logic _GEN = ~state & txValid;
      automatic logic _T_10;
      automatic logic _T_11;
      automatic logic _GEN_0 = _T_9 & io_wen;
      automatic logic _GEN_1;
      _T_10 = io_addr[7:0] == 8'h0;
      _T_11 = io_addr[7:0] == 8'h4;
      _GEN_1 = _T_10 | _T_11;
      if (~_GEN_0 | _GEN_1 | io_addr[7:0] != 8'hC) begin
      end
      else
        control <= io_wdata;
      if (|(spiCounter[7:2]))
        spiCounter <= 8'h0;
      else
        spiCounter <= spiCounter + 8'h1;
      spiClkReg <= (|(spiCounter[7:2])) ^ spiClkReg;
      if (state) begin
        automatic logic _T_6 = spiCounter == 8'h0 & spiClkReg;
        automatic logic _GEN_2 = state & _T_6 & (&spiBitCounter);
        state <= ~_GEN_2 & state;
        if (state & _T_6) begin
          spiShiftReg <= {spiShiftReg[6:0], 1'h0};
          spiBitCounter <= spiBitCounter + 3'h1;
        end
        spiCS <= _GEN_2 | spiCS;
        busy <= ~_T_6 | ~(&spiBitCounter);
      end
      else begin
        state <= txValid | state;
        if (txValid) begin
          spiShiftReg <= txData;
          spiBitCounter <= 3'h0;
        end
        spiCS <= ~txValid;
        busy <= txValid;
      end
      if (_GEN)
        spiDC <= txIsData;
      if (_GEN_0) begin
        if (_T_10)
          txData <= io_wdata[7:0];
        else if (_T_11)
          txData <= io_wdata[7:0];
        txIsData <= ~_T_10 & (_T_11 | txIsData);
      end
      txValid <= _T_9 & io_wen & _GEN_1 | ~_GEN & txValid;
    end
  end // always @(posedge)
  assign io_rdata =
    _T_9 & io_ren
      ? (io_addr[7:0] == 8'h8 ? {31'h1, busy} : io_addr[7:0] == 8'hC ? control : 32'h0)
      : 32'h0;
  assign io_ready = ~busy;
  assign io_spi_clk = spiClkReg;
  assign io_spi_mosi = spiShiftReg[7];
  assign io_spi_cs = spiCS;
  assign io_spi_dc = spiDC;
  assign io_spi_rst = control[1];
  assign io_backlight = control[0];
endmodule

module SimpleLCDWrapper(
  input         clock,
                reset,
  input  [31:0] io_reg_addr,
                io_reg_wdata,
  input         io_reg_wen,
                io_reg_ren,
                io_reg_valid,
  output [31:0] io_reg_rdata,
  output        io_reg_ready,
                io_lcd_spi_clk,
                io_lcd_spi_mosi,
                io_lcd_spi_cs,
                io_lcd_spi_dc,
                io_lcd_spi_rst,
                io_lcd_backlight
);

  TFTLCD lcd (
    .clock        (clock),
    .reset        (reset),
    .io_addr      (io_reg_addr),
    .io_wdata     (io_reg_wdata),
    .io_wen       (io_reg_wen),
    .io_ren       (io_reg_ren),
    .io_valid     (io_reg_valid),
    .io_rdata     (io_reg_rdata),
    .io_ready     (io_reg_ready),
    .io_spi_clk   (io_lcd_spi_clk),
    .io_spi_mosi  (io_lcd_spi_mosi),
    .io_spi_cs    (io_lcd_spi_cs),
    .io_spi_dc    (io_lcd_spi_dc),
    .io_spi_rst   (io_lcd_spi_rst),
    .io_backlight (io_lcd_backlight)
  );
endmodule

module SimpleGPIO(
  input         clock,
                reset,
  input  [31:0] io_reg_wdata,
  input         io_reg_wen,
                io_reg_ren,
                io_reg_valid,
  input  [15:0] io_gpio_in,
  output [31:0] io_reg_rdata,
  output [15:0] io_gpio_out
);

  reg [15:0] gpioOut;
  always @(posedge clock) begin
    if (reset)
      gpioOut <= 16'h0;
    else if (io_reg_valid & io_reg_wen)
      gpioOut <= io_reg_wdata[15:0];
  end // always @(posedge)
  assign io_reg_rdata = io_reg_valid & io_reg_ren ? {16'h0, io_gpio_in} : 32'h0;
  assign io_gpio_out = gpioOut;
endmodule

module SimpleEdgeAiSoC(
  input         clock,
                reset,
                io_uart_rx,
  input  [15:0] io_gpio_in,
  input         io_flash_spi_miso,
                io_psram_spi_miso,
                io_psram_spi_sio2_in,
                io_psram_spi_sio3_in,
  output        io_uart_tx,
                io_lcd_spi_clk,
                io_lcd_spi_mosi,
                io_lcd_spi_cs,
                io_lcd_spi_dc,
                io_lcd_spi_rst,
                io_lcd_backlight,
  output [15:0] io_gpio_out,
  output        io_trap,
                io_compact_irq,
                io_bitnet_irq,
                io_uart_tx_irq,
                io_uart_rx_irq,
                io_flash_spi_clk,
                io_flash_spi_mosi,
                io_flash_spi_cs,
                io_psram_spi_clk,
                io_psram_spi_cs,
                io_psram_spi_mosi,
                io_psram_spi_sio2_out,
                io_psram_spi_sio2_oe,
                io_psram_spi_sio3_out,
                io_psram_spi_sio3_oe
);

  wire [31:0] _gpio_io_reg_rdata;
  wire [31:0] _lcd_io_reg_rdata;
  wire        _lcd_io_reg_ready;
  wire [31:0] _uart_io_reg_rdata;
  wire        _uart_io_tx_irq;
  wire        _uart_io_rx_irq;
  wire [31:0] _bitnetAccel_io_reg_rdata;
  wire        _bitnetAccel_io_irq;
  wire [31:0] _compactAccel_io_reg_rdata;
  wire        _compactAccel_io_irq;
  wire [31:0] _decoder_io_cpu_rdata;
  wire        _decoder_io_cpu_ready;
  wire [31:0] _decoder_io_compact_addr;
  wire [31:0] _decoder_io_compact_wdata;
  wire        _decoder_io_compact_wen;
  wire        _decoder_io_compact_ren;
  wire        _decoder_io_compact_valid;
  wire [31:0] _decoder_io_bitnet_addr;
  wire [31:0] _decoder_io_bitnet_wdata;
  wire        _decoder_io_bitnet_wen;
  wire        _decoder_io_bitnet_ren;
  wire        _decoder_io_bitnet_valid;
  wire [31:0] _decoder_io_uart_addr;
  wire [31:0] _decoder_io_uart_wdata;
  wire        _decoder_io_uart_wen;
  wire        _decoder_io_uart_ren;
  wire        _decoder_io_uart_valid;
  wire [31:0] _decoder_io_lcd_addr;
  wire [31:0] _decoder_io_lcd_wdata;
  wire        _decoder_io_lcd_wen;
  wire        _decoder_io_lcd_ren;
  wire        _decoder_io_lcd_valid;
  wire [31:0] _decoder_io_gpio_wdata;
  wire        _decoder_io_gpio_wen;
  wire        _decoder_io_gpio_ren;
  wire        _decoder_io_gpio_valid;
  wire [31:0] _myCpu_io_bus_addr;
  wire [31:0] _myCpu_io_bus_wdata;
  wire        _myCpu_io_bus_wen;
  wire        _myCpu_io_bus_ren;
  MyCPUWrapper myCpu (
    .clock           (clock),
    .reset           (reset),
    .io_bus_rdata    (_decoder_io_cpu_rdata),
    .io_bus_ready    (_decoder_io_cpu_ready),
    .io_irq_external
      (_uart_io_rx_irq | _uart_io_tx_irq | _bitnetAccel_io_irq | _compactAccel_io_irq),
    .io_bus_addr     (_myCpu_io_bus_addr),
    .io_bus_wdata    (_myCpu_io_bus_wdata),
    .io_bus_wen      (_myCpu_io_bus_wen),
    .io_bus_ren      (_myCpu_io_bus_ren)
  );
  SimpleAddressDecoder decoder (
    .io_cpu_addr      (_myCpu_io_bus_addr),
    .io_cpu_wdata     (_myCpu_io_bus_wdata),
    .io_cpu_wen       (_myCpu_io_bus_wen),
    .io_cpu_ren       (_myCpu_io_bus_ren),
    .io_compact_rdata (_compactAccel_io_reg_rdata),
    .io_bitnet_rdata  (_bitnetAccel_io_reg_rdata),
    .io_uart_rdata    (_uart_io_reg_rdata),
    .io_lcd_rdata     (_lcd_io_reg_rdata),
    .io_lcd_ready     (_lcd_io_reg_ready),
    .io_gpio_rdata    (_gpio_io_reg_rdata),
    .io_cpu_rdata     (_decoder_io_cpu_rdata),
    .io_cpu_ready     (_decoder_io_cpu_ready),
    .io_compact_addr  (_decoder_io_compact_addr),
    .io_compact_wdata (_decoder_io_compact_wdata),
    .io_compact_wen   (_decoder_io_compact_wen),
    .io_compact_ren   (_decoder_io_compact_ren),
    .io_compact_valid (_decoder_io_compact_valid),
    .io_bitnet_addr   (_decoder_io_bitnet_addr),
    .io_bitnet_wdata  (_decoder_io_bitnet_wdata),
    .io_bitnet_wen    (_decoder_io_bitnet_wen),
    .io_bitnet_ren    (_decoder_io_bitnet_ren),
    .io_bitnet_valid  (_decoder_io_bitnet_valid),
    .io_uart_addr     (_decoder_io_uart_addr),
    .io_uart_wdata    (_decoder_io_uart_wdata),
    .io_uart_wen      (_decoder_io_uart_wen),
    .io_uart_ren      (_decoder_io_uart_ren),
    .io_uart_valid    (_decoder_io_uart_valid),
    .io_lcd_addr      (_decoder_io_lcd_addr),
    .io_lcd_wdata     (_decoder_io_lcd_wdata),
    .io_lcd_wen       (_decoder_io_lcd_wen),
    .io_lcd_ren       (_decoder_io_lcd_ren),
    .io_lcd_valid     (_decoder_io_lcd_valid),
    .io_gpio_wdata    (_decoder_io_gpio_wdata),
    .io_gpio_wen      (_decoder_io_gpio_wen),
    .io_gpio_ren      (_decoder_io_gpio_ren),
    .io_gpio_valid    (_decoder_io_gpio_valid)
  );
  SimpleCompactAccel compactAccel (
    .clock        (clock),
    .reset        (reset),
    .io_reg_addr  (_decoder_io_compact_addr),
    .io_reg_wdata (_decoder_io_compact_wdata),
    .io_reg_wen   (_decoder_io_compact_wen),
    .io_reg_ren   (_decoder_io_compact_ren),
    .io_reg_valid (_decoder_io_compact_valid),
    .io_reg_rdata (_compactAccel_io_reg_rdata),
    .io_irq       (_compactAccel_io_irq)
  );
  SimpleBitNetAccel bitnetAccel (
    .clock        (clock),
    .reset        (reset),
    .io_reg_addr  (_decoder_io_bitnet_addr),
    .io_reg_wdata (_decoder_io_bitnet_wdata),
    .io_reg_wen   (_decoder_io_bitnet_wen),
    .io_reg_ren   (_decoder_io_bitnet_ren),
    .io_reg_valid (_decoder_io_bitnet_valid),
    .io_reg_rdata (_bitnetAccel_io_reg_rdata),
    .io_irq       (_bitnetAccel_io_irq)
  );
  SimpleUARTWrapper uart (
    .clock        (clock),
    .reset        (reset),
    .io_reg_addr  (_decoder_io_uart_addr),
    .io_reg_wdata (_decoder_io_uart_wdata),
    .io_reg_wen   (_decoder_io_uart_wen),
    .io_reg_ren   (_decoder_io_uart_ren),
    .io_reg_valid (_decoder_io_uart_valid),
    .io_rx        (io_uart_rx),
    .io_reg_rdata (_uart_io_reg_rdata),
    .io_tx        (io_uart_tx),
    .io_tx_irq    (_uart_io_tx_irq),
    .io_rx_irq    (_uart_io_rx_irq)
  );
  SimpleLCDWrapper lcd (
    .clock            (clock),
    .reset            (reset),
    .io_reg_addr      (_decoder_io_lcd_addr),
    .io_reg_wdata     (_decoder_io_lcd_wdata),
    .io_reg_wen       (_decoder_io_lcd_wen),
    .io_reg_ren       (_decoder_io_lcd_ren),
    .io_reg_valid     (_decoder_io_lcd_valid),
    .io_reg_rdata     (_lcd_io_reg_rdata),
    .io_reg_ready     (_lcd_io_reg_ready),
    .io_lcd_spi_clk   (io_lcd_spi_clk),
    .io_lcd_spi_mosi  (io_lcd_spi_mosi),
    .io_lcd_spi_cs    (io_lcd_spi_cs),
    .io_lcd_spi_dc    (io_lcd_spi_dc),
    .io_lcd_spi_rst   (io_lcd_spi_rst),
    .io_lcd_backlight (io_lcd_backlight)
  );
  SimpleGPIO gpio (
    .clock        (clock),
    .reset        (reset),
    .io_reg_wdata (_decoder_io_gpio_wdata),
    .io_reg_wen   (_decoder_io_gpio_wen),
    .io_reg_ren   (_decoder_io_gpio_ren),
    .io_reg_valid (_decoder_io_gpio_valid),
    .io_gpio_in   (io_gpio_in),
    .io_reg_rdata (_gpio_io_reg_rdata),
    .io_gpio_out  (io_gpio_out)
  );
  assign io_trap = 1'h0;
  assign io_compact_irq = _compactAccel_io_irq;
  assign io_bitnet_irq = _bitnetAccel_io_irq;
  assign io_uart_tx_irq = _uart_io_tx_irq;
  assign io_uart_rx_irq = _uart_io_rx_irq;
  assign io_flash_spi_clk = 1'h0;
  assign io_flash_spi_mosi = 1'h0;
  assign io_flash_spi_cs = 1'h1;
  assign io_psram_spi_clk = 1'h0;
  assign io_psram_spi_cs = 1'h1;
  assign io_psram_spi_mosi = 1'h0;
  assign io_psram_spi_sio2_out = 1'h0;
  assign io_psram_spi_sio2_oe = 1'h0;
  assign io_psram_spi_sio3_out = 1'h0;
  assign io_psram_spi_sio3_oe = 1'h0;
endmodule

